<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategy Science Conference 2026 - Paper Review System</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;500;600&family=DM+Sans:wght@400;500;600&display=swap"
        rel="stylesheet">

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <!-- SheetJS for XLSX export -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>

    <style>
        :root {
            --bg-primary: #f8f7f5;
            --bg-secondary: #ffffff;
            --text-primary: #1a1a1a;
            --text-secondary: #565A5C;
            --accent: #CFB87C;
            --accent-dark: #A89458;
            --accent-light: #FDF8EC;
            --cu-black: #000000;
            --cu-gold: #CFB87C;
            --success: #276749;
            --success-bg: #f0fff4;
            --warning: #b7791f;
            --warning-bg: #fefcbf;
            --danger: #c53030;
            --danger-bg: #fff5f5;
            --border: #e2e2e2;
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            --header-border: #CFB87C;
        }



        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'DM Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }


        .container {
            /* Wider canvas for all tabs (incl. Results table) */
            max-width: min(1600px, 96vw);
            margin: 0 auto;
            padding: 40px 20px;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 30px;
            border-bottom: 3px solid var(--cu-gold);
            position: relative;
        }

        header::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 3px;
            background: var(--cu-black);
        }

        h1 {
            font-family: 'Crimson Pro', serif;
            font-size: 2.4rem;
            font-weight: 600;
            color: var(--cu-black);
            margin-bottom: 8px;
        }



        .subtitle {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .venue-info {
            margin-top: 12px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .venue-info strong {
            color: var(--cu-gold);
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            background: var(--accent-light);
            color: var(--accent-dark);
            border-radius: 20px;
            font-size: 0.8rem;
            border: 1px solid var(--cu-gold);
            font-weight: 500;
            margin-top: 12px;
        }

        /* Login Screen */
        .login-screen {
            max-width: 400px;
            margin: 0 auto;
        }

        .login-screen .card {
            text-align: center;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
        }

        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            font-family: inherit;
            font-size: 0.9rem;
            color: var(--text-secondary);
            cursor: pointer;
            position: relative;
            transition: color 0.2s;
        }

        .tab:hover {
            color: var(--text-primary);
        }

        .tab.active {
            color: var(--cu-black);
            font-weight: 600;
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--cu-gold);
        }

        /* Cards */
        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: var(--shadow);
        }

        .card h2 {
            font-family: 'Crimson Pro', serif;
            font-size: 1.3rem;
            font-weight: 500;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        /* Forms */
        .form-group {
            margin-bottom: 16px;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        label {
            display: block;
            font-size: 0.85rem;
            font-weight: 500;
            margin-bottom: 6px;
            color: var(--text-secondary);
        }

        input,
        textarea,
        select {
            width: 100%;
            padding: 10px 14px;
            border: 1px solid var(--border);
            border-radius: 8px;
            font-family: inherit;
            font-size: 0.95rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-light);
        }

        textarea {
            min-height: 80px;
            resize: vertical;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--cu-black);
            color: var(--cu-gold);
            font-weight: 500;
        }

        .btn-primary:hover {
            background: #333;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--accent-light);
            border-color: var(--cu-gold);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-success:hover {
            background: #1e5038;
        }

        .btn-warning {
            background: var(--warning);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-danger:hover {
            background: #9c2626;
        }

        .btn-sm {
            padding: 6px 14px;
            font-size: 0.8rem;
        }

        /* Tables */
        .table-wrapper {
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th,
        td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        th {
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
            cursor: pointer;
            user-select: none;
        }

        th:hover {
            color: var(--accent);
        }

        td {
            font-size: 0.9rem;
        }

        tr:hover {
            background: var(--bg-primary);
        }

        /* Status badges */
        .status {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .status-pending {
            background: #fef3c7;
            color: #92400e;
        }

        .status-yes {
            background: #38a169;
            color: #ffffff;
        }

        .status-maybe-yes {
            background: #c6f6d5;
            color: #22543d;
        }

        .status-maybe-no {
            background: #fed7d7;
            color: #822727;
        }

        .status-no {
            background: #e53e3e;
            color: #ffffff;
        }

        .status-has-file {
            background: var(--accent-light);
            color: var(--accent);
        }

        /* Score display */
        .score {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .score-high {
            color: var(--success);
        }

        .score-mid {
            color: var(--warning);
        }

        .score-low {
            color: var(--danger);
        }

        /* Rank badge */
        .rank {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .rank-top {
            background: #faf089;
            color: #744210;
        }

        .rank-normal {
            background: var(--bg-primary);
            color: var(--text-secondary);
        }

        /* Reviewer tags in assignments */
        .reviewer-tag {
            display: inline-block;
            padding: 4px 10px;
            background: #e2e8f0;
            /* Darker grey/blue for better visibility */
            color: #2d3748;
            /* Dark text */
            border: 1px solid #cbd5e0;
            border-radius: 4px;
            font-size: 0.85rem;
            margin: 2px;
            font-weight: 600;
        }

        .reviewer-tag .remove {
            cursor: pointer;
            margin-left: 6px;
            color: #e53e3e;
            /* Red for remove action */
            font-weight: bold;
        }

        .reviewer-tag .remove:hover {
            color: #c53030;
        }

        /* Link box */
        .link-box {
            background: #f7fafc;
            border: 1px solid #cbd5e0;
            border-radius: 8px;
            padding: 12px;
            font-family: monospace;
            font-size: 0.9rem;
            color: #2d3748;
            /* Dark text for readability */
            word-break: break-all;
            margin: 8px 0;
            user-select: all;
            /* Easier selection */
        }

        .header-logo {
            max-width: 300px;
            height: auto;
            margin-bottom: 20px;
        }

        /* Header logo */
        .header-logo {
            max-width: 300px;
            height: auto;
            margin-bottom: 20px;
        }

        /* Fix assignment card text visibility */
        .assignment-paper {
            color: var(--text-primary);
        }

        .assignment-paper.complete {
            border-color: #38a169;
            border-width: 2px;
            background: var(--success-bg);
            color: var(--text-primary);
        }

        .assignment-paper strong {
            color: var(--text-primary);
        }

        .paper-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            overflow: hidden;
            box-sizing: border-box;
        }

        .paper-card.reviewed {
            opacity: 0.7;
            border-color: var(--success);
        }

        .paper-card.nominated-card {
            border-color: var(--accent);
            border-width: 2px;
        }

        .paper-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            gap: 16px;
            flex-wrap: wrap;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        .paper-content {
            flex: 1;
            min-width: 0;
            width: 100%;
        }

        .nomination-box {
            margin-top: 12px;
            padding-top: 8px;
            border-top: 1px solid var(--border);
        }

        .nomination-box label {
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--accent-dark);
            line-height: 1.4;
            margin: 0;
            padding: 0;
        }

        .nomination-box input[type="radio"] {
            flex-shrink: 0;
            margin: 0;
            width: 18px;
            height: 18px;
        }

        .nomination-text {
            display: inline-block;
            white-space: normal;
            word-wrap: break-word;
        }

        .nomination-badge {
            display: inline-block;
            white-space: nowrap;
        }

        .cell-ellipsis {
            max-width: 220px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .nomination-question {
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            flex-wrap: wrap;
        }

        .nomination-question-text {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .nomination-actions {
            display: inline-flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .nom-yes-active {
            background: var(--accent-light);
            border: 1px solid var(--cu-gold);
        }

        .nom-no-active {
            opacity: 0.8;
        }

        .paper-title {
            font-family: 'Crimson Pro', serif;
            font-size: 1.2rem;
            font-weight: 500;
            margin-bottom: 8px;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .paper-id {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }

        /* Review options - 4 buttons */
        .review-options {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-top: 16px;
        }

        .review-option {
            padding: 16px 12px;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--bg-secondary);
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .review-option:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .review-option .option-label {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 4px;
        }

        .review-option .option-score {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .review-option.opt-no {
            border-color: #c53030;
            background: #fc8181;
            color: #ffffff;
        }

        .review-option.opt-no:hover {
            background: #e53e3e;
        }

        .review-option.opt-maybe-no {
            border-color: #ed8936;
            background: #feebc8;
        }

        .review-option.opt-maybe-no:hover {
            background: #fbd38d;
        }

        .review-option.opt-maybe-yes {
            border-color: #48bb78;
            background: #c6f6d5;
        }

        .review-option.opt-maybe-yes:hover {
            background: #9ae6b4;
        }

        .review-option.opt-yes {
            border-color: #2f855a;
            background: #68d391;
            color: #ffffff;
        }

        .review-option.opt-yes:hover {
            background: #48bb78;
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .stat-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            border-top: 3px solid var(--cu-gold);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 600;
            color: var(--cu-black);
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Alerts */
        .alert {
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .alert-info {
            background: var(--accent-light);
            color: var(--accent);
        }

        .alert-success {
            background: var(--success-bg);
            color: var(--success);
        }

        .alert-warning {
            background: #fef3c7;
            color: #92400e;
        }

        .alert-danger {
            background: var(--danger-bg);
            color: var(--danger);
        }

        /* Hidden sections */
        .hidden {
            display: none;
        }

        /* Actions row */
        .actions-row {
            display: flex;
            gap: 12px;
            margin-top: 16px;
            flex-wrap: wrap;
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        /* Reviewer info header */
        /* Reviewer info header - Light Theme */
        .reviewer-header {
            background: #ffffff;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            /* Softer shadow */
            color: var(--text-primary);
            border-left: 5px solid var(--cu-gold);
            border-top: 1px solid var(--border);
            border-right: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
        }

        .reviewer-header h2 {
            color: var(--cu-black);
            /* Black title */
            margin-bottom: 8px;
            font-family: 'Crimson Pro', serif;
            font-size: 1.8rem;
        }

        .reviewer-header h2 span {
            color: var(--cu-black) !important;
        }

        .reviewer-header p,
        .reviewer-header span {
            color: var(--text-secondary) !important;
            /* Revert to normal dark grey text */
        }

        /* Remove redundant p rule */

        .progress-bar {
            height: 8px;
            background: #e5e5e5;
            border-radius: 4px;
            margin-top: 12px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--cu-gold) 0%, #e8d4a0 100%);
            border-radius: 4px;
            transition: width 0.3s;
        }

        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 16px 24px;
            background: var(--text-primary);
            color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s;
            z-index: 1000;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        /* Download button */
        .download-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 10px 16px;
            background: var(--accent);
            color: white;
            border-radius: 8px;
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 16px;
            cursor: pointer;
            border: none;
        }

        .download-btn:hover {
            background: #1e3a5f;
        }

        /* Connection status */
        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .connection-status.connected {
            background: var(--success-bg);
            color: var(--success);
        }

        .connection-status.disconnected {
            background: var(--danger-bg);
            color: var(--danger);
        }

        /* Loading spinner */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Assignment item */
        .assignment-paper {
            padding: 16px;
            border: 1px solid var(--border);
            border-radius: 8px;
            margin-bottom: 12px;
            background: var(--bg-secondary);
        }

        .assignment-paper.complete {
            border-color: #38a169;
            border-width: 2px;
            background: #e6ffed;
        }

        .reviewer-tag {
            display: inline-block;
            padding: 4px 10px;
            background: var(--accent-light);
            color: var(--accent);
            border-radius: 4px;
            font-size: 0.8rem;
            margin: 2px;
        }

        .reviewer-tag .remove {
            cursor: pointer;
            margin-left: 6px;
            color: var(--danger);
        }

        /* Cutoff row - the LAST accepted paper gets a bottom border */
        .cutoff-row {
            background: #fffbeb !important;
            border-bottom: 3px solid var(--warning) !important;
        }

        .above-cutoff {
            background: #fffbeb !important;
        }

        /* Filter row */
        .filter-row {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-row label {
            margin-bottom: 0;
        }

        .filter-row input,
        .filter-row select {
            width: auto;
        }

        /* Capacity bar */
        .capacity-bar {
            height: 6px;
            background: var(--border);
            border-radius: 3px;
            margin-top: 4px;
            overflow: hidden;
        }

        .capacity-fill {
            height: 100%;
            background: var(--accent);
            border-radius: 3px;
        }

        .capacity-fill.full {
            background: var(--danger);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: var(--bg-secondary);
            padding: 24px;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .modal-content h2 {
            color: var(--text-primary);
            font-weight: 600;
        }

        .modal-content h4 {
            color: var(--text-primary);
            font-weight: 600;
        }

        .modal-content strong {
            color: var(--text-primary);
        }

        .modal-close {
            position: absolute;
            top: 16px;
            right: 16px;
            cursor: pointer;
            font-size: 1.5rem;
            color: var(--text-secondary);
        }

        .info-btn {
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            padding: 2px 4px;
            transition: transform 0.2s;
        }

        .info-btn:hover {
            transform: scale(1.2);
        }

        .keyword-tag {
            display: inline-block;
            background: var(--bg-secondary);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85rem;
            margin-right: 6px;
            margin-bottom: 6px;
        }

        .expertise-tag {
            display: inline-block;
            background: #d4f4dd;
            color: #1e6636;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            margin: 2px;
            font-weight: 500;
        }

        .method-tag {
            display: inline-block;
            background: #e0e7ff;
            color: #3730a3;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            margin: 2px;
            font-weight: 600;
        }

        .conflict-row {
            background: #fef3c7 !important;
            border-left: 4px solid #f59e0b !important;
        }

        /* Admin Judgment Dropdown */
        .judgment-select {
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid var(--border);
            font-size: 0.85rem;
            cursor: pointer;
        }

        .judgment-select.accepted {
            background: #d4f4dd;
            border-color: #38a169;
            color: #1e6636;
        }

        .judgment-select.waitlisted {
            background: #fef3c7;
            border-color: #d69e2e;
            color: #975a16;
        }

        .judgment-select.rejected {
            background: #fed7d7;
            border-color: #e53e3e;
            color: #c53030;
        }
    </style>
</head>

<body>
    <!-- Modal -->
    <div id="paper-modal" class="modal-overlay" onclick="closeModal(event)">
        <div class="modal-content">
            <span class="modal-close"
                onclick="document.getElementById('paper-modal').style.display='none'">&times;</span>
            <h2 id="modal-title" style="margin-bottom: 16px; padding-right: 20px;">Paper Title</h2>
            <div style="margin-bottom: 16px;">
                <strong>ID:</strong> <span id="modal-id">P001</span>
            </div>



            <div id="modal-authors-section" style="margin-bottom: 16px;">
                <h4 style="margin-bottom: 8px; color: var(--text-secondary);">Authors & Affiliations</h4>
                <div id="modal-authors" style="font-size: 0.95rem; color: var(--text-primary);"></div>
                <div id="modal-affiliations" style="font-size: 0.85rem; color: var(--text-secondary); margin-top:4px;">
                </div>
            </div>

            <div id="modal-keywords-section" style="margin-bottom: 16px;">
                <h4 style="margin-bottom: 8px; color: var(--text-secondary);">Keywords</h4>
                <div id="modal-keywords"></div>
            </div>

            <div id="modal-abstract-section" style="margin-bottom: 16px;">
                <h4 style="margin-bottom: 8px; color: var(--text-secondary);">Abstract / Details</h4>
                <p id="modal-abstract" style="line-height: 1.5; color: var(--text-primary);">No details available.</p>
            </div>

            <div style="margin-top: 24px; text-align: right;">
                <a id="modal-link" href="#" target="_blank" class="btn-primary" style="text-decoration: none;">View
                    PDF</a>
            </div>
        </div>
    </div>
    </style>
    </head>

    <body>
        <!-- Banner removed as requested -->
        <div class="connection-status" id="connection-status" style="top: 10px; right: 10px;">Connecting...</div>

        <div class="container">
            <header>
                <img src="leeds-left_orig.png" alt="Leeds School of Business" class="header-logo">
                <h1>Strategy Science Conference 2026</h1>
                <p class="subtitle">Paper Review Management System</p>
                <p class="venue-info">Hosted at <strong>Leeds School of Business</strong> ¬∑ Boulder, Colorado</p>
                <span class="badge" id="mode-badge">Loading...</span>
            </header>

            <!-- Admin Login -->
            <div id="admin-login" class="login-screen hidden">
                <div class="card">
                    <h2>üîê Admin Login</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 20px;">
                        Sign in to access the management panel.
                    </p>
                    <div id="auth-error" class="alert alert-danger hidden"
                        style="font-size: 0.9rem; margin-bottom: 15px;"></div>
                    <div class="form-group">
                        <label>Email</label>
                        <input type="email" id="login-email" placeholder="admin@strategyscience.org">
                    </div>
                    <div class="form-group">
                        <label>Password</label>
                        <input type="password" id="login-password" placeholder="Password"
                            onkeypress="if(event.key==='Enter')adminLogin()">
                    </div>
                    <button class="btn-primary" onclick="adminLogin()" style="width: 100%;">
                        Login
                    </button>
                </div>
            </div>

            <!-- Admin View -->
            <div id="admin-view" class="hidden">
                <div class="tabs">
                    <button class="tab active" data-tab="papers">Papers</button>
                    <button class="tab" data-tab="reviewers">Reviewers</button>
                    <button class="tab" data-tab="assignments">Assignments</button>
                    <button class="tab" data-tab="results">Results & Rankings</button>
                </div>

                <!-- Papers Tab -->
                <div id="tab-papers" class="tab-content">
                    <div class="card">
                        <h2>Add Paper</h2>
                        <p style="color: var(--text-secondary); margin-bottom: 16px;">
                            Add papers with PDF links. Author info is hidden from reviewers.
                        </p>

                        <div class="form-row">
                            <div class="form-group">
                                <label>Paper Title (or leave as TBD)</label>
                                <input type="text" id="paper-title" placeholder="Paper title or TBD">
                            </div>
                            <div class="form-group">
                                <label>PDF Link (Google Drive / Dropbox)</label>
                                <input type="url" id="paper-pdf-link" placeholder="https://drive.google.com/...">
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>Keywords (optional)</label>
                                <input type="text" id="paper-keywords"
                                    placeholder="e.g., innovation, entrepreneurship, strategy">
                            </div>
                            <div class="form-group">
                                <label>Abstract (optional)</label>
                                <textarea id="paper-abstract" placeholder="Paper abstract or summary..." rows="3"
                                    style="resize: vertical;"></textarea>
                            </div>
                        </div>
                        <div class="actions-row">
                            <button class="btn-primary" onclick="addPaper()">Add Paper</button>
                            <button class="btn-secondary" onclick="loadSamplePapers()">Load 200 Sample Papers
                                (Demo)</button>
                        </div>

                        <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border);">
                            <h3 style="font-size: 1rem; margin-bottom: 12px;">üìÅ Import from CSV</h3>
                            <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 12px;">
                                Upload a CSV file with columns: <code>id</code>, <code>title</code>, <code>link</code>
                            </p>
                            <input type="file" id="csv-file-input" accept=".csv" style="margin-bottom: 12px;">
                            <button class="btn-secondary" onclick="importFromCSV()">Import CSV</button>
                        </div>
                    </div>

                    <div class="card">
                        <h2>Paper List <span id="paper-count"
                                style="color: var(--text-secondary); font-weight: normal;">(0)</span></h2>
                        <div id="papers-list">
                            <div class="loading">
                                <div class="spinner"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Reviewers Tab -->
                <div id="tab-reviewers" class="tab-content hidden">
                    <div class="card">
                        <h2>Add Reviewer</h2>
                        <div class="form-row">
                            <div class="form-group">
                                <label>Name</label>
                                <input type="text" id="reviewer-name" placeholder="Dr. Name">
                            </div>
                            <div class="form-group">
                                <label>Email</label>
                                <input type="email" id="reviewer-email" placeholder="email@university.edu">
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>Max Papers (leave empty for no limit)</label>
                                <input type="number" id="reviewer-max" placeholder="e.g., 15" min="1">
                            </div>
                            <div class="form-group">
                                <label>Expertise / Notes (optional)</label>
                                <input type="text" id="reviewer-expertise"
                                    placeholder="e.g., quantitative methods, M&A">
                            </div>
                        </div>
                        <div class="actions-row">
                            <button class="btn-primary" onclick="addReviewer()">Add Reviewer</button>
                            <button class="btn-secondary" onclick="loadDefaultReviewers()">Load Default
                                Reviewers</button>
                        </div>
                    </div>

                    <div class="card">
                        <h2>Reviewer List <span id="reviewer-count"
                                style="color: var(--text-secondary); font-weight: normal;">(0)</span></h2>
                        <div id="reviewers-list">
                            <div class="loading">
                                <div class="spinner"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Assignments Tab -->
                <div id="tab-assignments" class="tab-content hidden">
                    <div class="card">
                        <h2>Manual Paper Assignment</h2>
                        <p style="color: var(--text-secondary); margin-bottom: 16px;">
                            Assign 2 reviewers to each paper. You can see each reviewer's expertise and current
                            workload.
                        </p>

                        <div
                            style="margin-bottom: 20px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">
                            <h3 style="font-size: 1rem; margin-bottom: 12px; color: var(--text-primary);">üìÅ Import
                                Assignments from CSV</h3>
                            <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 12px;">
                                Upload a CSV with columns: <code>paper_id</code>, <code>reviewer_1</code>,
                                <code>reviewer_2</code> (use reviewer names)
                            </p>
                            <input type="file" id="assignments-csv-input" accept=".csv" style="margin-bottom: 12px;">
                            <button class="btn-secondary btn-sm" onclick="importAssignmentsCSV()">Import
                                Assignments</button>
                        </div>

                        <div class="filter-row">
                            <label>Filter:</label>
                            <select id="filter-assignment-status" onchange="renderAssignments()">
                                <option value="all">All Papers</option>
                                <option value="incomplete">Needs Reviewers</option>
                                <option value="complete">Fully Assigned</option>
                            </select>
                            <button class="btn-secondary btn-sm" onclick="generateRandomAssignments()">üé≤ Auto Assign
                                (Random)</button>
                            <button class="btn-secondary btn-sm"
                                onclick="renderAssignments(); renderReviewerWorkload(); showToast('Refreshed')">üîÑ
                                Refresh</button>
                            <button class="btn-danger btn-sm" onclick="clearAssignments()">üóëÔ∏è Clear All</button>
                        </div>

                        <div id="assignments-list">
                            <div class="empty-state">
                                <p>Add papers first to make assignments.</p>
                            </div>
                        </div>
                    </div>

                    <div class="card">
                        <h2>Reviewer Workload</h2>
                        <div id="reviewer-workload">
                            <div class="empty-state">
                                <p>Add reviewers first.</p>
                            </div>
                        </div>
                    </div>

                    <div class="card">
                        <h2>Reviewer Links</h2>
                        <p style="color: var(--text-secondary); margin-bottom: 16px;">
                            Share these unique links with each reviewer. No author info shown.
                        </p>
                        <div id="reviewer-links">
                            <div class="empty-state">
                                <p>Assign papers to reviewers first.</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Results Tab -->
                <div id="tab-results" class="tab-content hidden">
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-number" id="stat-total-papers">0</div>
                            <div class="stat-label">Total Papers</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="stat-reviewed">0</div>
                            <div class="stat-label">Fully Reviewed</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="stat-pending">0</div>
                            <div class="stat-label">Pending</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="stat-avg-score">-</div>
                            <div class="stat-label">Conflicts</div>
                        </div>
                    </div>

                    <div class="card">
                        <h2>Rankings & Results</h2>
                        <div class="filter-row" style="flex-wrap: wrap; gap: 12px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <label>Accept Top:</label>
                                <input type="number" id="cutoff-number" placeholder="e.g., 50" min="1"
                                    style="width: 80px;" onchange="applyDefaultJudgments(); renderResults()">
                                <span style="color: var(--text-secondary);">papers</span>
                            </div>

                            <div style="display: flex; align-items: center; gap: 8px;">
                                <label>Filter:</label>
                                <select id="conflict-filter" onchange="renderResults()"
                                    style="padding: 6px 10px; border-radius: 6px; border: 1px solid var(--border);">
                                    <option value="all">All Papers</option>
                                    <option value="conflicts">‚ö†Ô∏è Conflicts Only</option>
                                    <option value="nominated">üèÜ Nominated Papers</option>
                                    <option value="accepted">‚úì Accepted</option>
                                    <option value="waitlisted">‚è≥ Waitlisted</option>
                                    <option value="rejected">‚úó Rejected</option>
                                    <option value="pending">Pending Decision</option>
                                </select>
                            </div>

                            <div style="display: flex; align-items: center; gap: 8px;">
                                <label>Sort:</label>
                                <select id="sort-order" onchange="renderResults()"
                                    style="padding: 6px 10px; border-radius: 6px; border: 1px solid var(--border);">
                                    <option value="score">By Score</option>
                                    <option value="accepted-first">Accepted First</option>
                                    <option value="waitlisted-first">Waitlisted First</option>
                                    <option value="rejected-first">Rejected First</option>
                                </select>
                            </div>

                            <div style="display:flex; gap:8px;">
                                <button class="btn-secondary btn-sm" onclick="performDemoReview()">ü§ñ Demo
                                    Review</button>
                                <button class="btn-secondary btn-sm"
                                    onclick="applyDefaultJudgments(); renderResults(); showToast('Refreshed')">üîÑ Apply
                                    & Refresh</button>
                                <button class="btn-secondary btn-sm" onclick="exportResults()">Export XLSX</button>
                            </div>
                        </div>

                        <div class="table-wrapper">
                            <div id="results-list">
                                <div class="loading">
                                    <div class="spinner"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="card">
                        <h2>Danger Zone</h2>
                        <button class="btn-danger" onclick="clearAllData()">Reset All Data</button>
                    </div>
                </div>
            </div>

            <!-- Reviewer View -->
            <div id="reviewer-view" class="hidden">
                <div class="reviewer-header">
                    <h2>Welcome, <span id="reviewer-name-display"></span></h2>
                    <p style="color: var(--text-secondary);">You have <span id="reviewer-paper-count">0</span> papers to
                        review.</p>
                    <div class="alert alert-warning" style="margin-top: 16px; margin-bottom: 12px;">
                        <strong>üìÖ Review Deadline: February 20, 2026</strong><br>
                        <span style="font-size: 0.9rem;">Thank you for contributing to the Strategy Science Conference!
                            Your expertise is invaluable to the review process.</span>
                    </div>
                    <p style="font-size: 0.85rem; color: var(--accent); margin-top: 8px;">
                        ‚ö†Ô∏è Author information is hidden.
                    </p>
                    <div class="alert alert-info" style="margin-top: 16px; margin-bottom: 16px;">
                        <strong>üèÜ Best Paper Nomination:</strong> Please nominate <strong>one best paper</strong> from
                        your assigned papers using the nomination option below each paper.
                        <div id="current-nomination-display"
                            style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(207,184,124,0.3);">
                            <strong>Your current nomination:</strong> <span id="nominated-paper-id"
                                style="font-weight: 600; color: var(--cu-gold);">None selected</span>
                        </div>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="review-progress" style="width: 0%"></div>
                    </div>
                    <p style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 8px;">
                        <span id="completed-count">0</span> of <span id="total-assigned">0</span> completed
                    </p>
                </div>

                <div id="reviewer-papers"></div>

                <div class="card hidden" id="all-done-card">
                    <div class="alert alert-success">
                        <strong>Thank you!</strong> You have completed all your reviews.
                    </div>
                </div>
            </div>
        </div>

        <div class="toast" id="toast"></div>

        <script>
            // =====================
            // CONFIG
            // =====================
            const firebaseConfig = {
                apiKey: "AIzaSyCbFLv1DAaDPkYHzo7yieompZXI79AYx2o",
                authDomain: "strategyscience2026.firebaseapp.com",
                projectId: "strategyscience2026",
                databaseURL: "https://strategyscience2026-default-rtdb.firebaseio.com"
            };

            // const ADMIN_PASSWORD = "CUBoulder2026"; // REMOVED: Using Firebase Auth

            // =====================
            // TEST MODE - Set to false for production
            // =====================
            const TEST_MODE = false;
            const TEST_EMAIL = "yupengjim@gmail.com";

            const SCORE_MAP = { 'no': 1, 'maybe-no': 2, 'maybe-yes': 3, 'yes': 4 };
            const SCORE_LABELS = { 'no': 'No', 'maybe-no': 'Maybe No', 'maybe-yes': 'Maybe Yes', 'yes': 'Yes' };

            // Expertise keywords from committee_table.csv (Method first, then theories, then topics)
            const REVIEWER_EXPERTISE = {
                "Janet Bercovitz": { method: "Quantitative", keywords: ["Transaction Cost Economics", "Org. Learning", "Academic Entrepreneurship", "Tech Transfer"] },
                "Danielle Bovenberg": { method: "Qualitative", keywords: ["Craft Knowledge", "Org. Theory", "Innovation", "Knowledge Diffusion"] },
                "Mukund Chari": { method: "Quantitative", keywords: ["Transaction Cost Economics", "Agency Theory", "Intellectual Property", "Patent Systems"] },
                "Ashton Hawk": { method: "Quantitative", keywords: ["Resource-Based View", "Dynamic Capabilities", "Investment Speed", "Political Capital"] },
                "Sina Sokhan": { method: "Quantitative", keywords: ["Knowledge Recombination", "IP Theory", "Innovation Process", "Pharma Innovation"] },
                "MJ Yang": { method: "Quant/Mixed", keywords: ["Complementarity Theory", "RBV", "CEO Strategy", "Tech Uniqueness"] },
                "Kenneth Huang": { method: "Quant/Mixed", keywords: ["Institutional Theory", "Knowledge-Based View", "IP Strategy", "Innovation in China"] },
                "Aldona Kapacinskaite": { method: "Quantitative", keywords: ["Resource-Based View", "Appropriability Theory", "Trade Secrets", "Platform Competition"] },
                "Wesley W. Koo": { method: "Quant/Mixed", keywords: ["Platform Theory", "Institutional Theory", "Platform Governance", "Digital Entrepreneurship"] },
                "Catherine Magelssen": { method: "Quantitative", keywords: ["Property Rights Theory", "TCE", "Multinational Strategy", "IP Governance"] },
                "Anparasan Mahalingam": { method: "Quantitative", keywords: ["Platform Theory", "Org. Economics", "Digital Corporate Strategy", "Platform Governance"] },
                "Francisco Morales": { method: "Quantitative", keywords: ["Strategic Human Capital", "Signaling Theory", "Human Capital", "Immigration"] },
                "Metin Sengul": { method: "Quantitative", keywords: ["Org. Design Theory", "Behavioral Theory", "Org. Design", "Multiunit Firms"] },
                "Xiaoli Tang": { method: "Quant/Mixed", keywords: ["Institutional Theory", "Stakeholder Theory", "Accountable Secrecy", "Self-Regulation"] },
                "Andy Wu": { method: "Quant/Mixed", keywords: ["Org. Design Theory", "Platform Theory", "Entrepreneurship", "Platform Ecosystems"] },
                "Mingtao Xu": { method: "Quantitative", keywords: ["Property Rights Theory", "Org. Learning", "AI & Strategy", "Patent Litigation"] },
                "Tony Tong": { method: "Mixed", keywords: ["Strategy", "Innovation", "International Business"] },
                "Yuchen Zhang": { method: "Quant/Mixed", keywords: ["Knowledge-Based View", "Platform Theory", "Platform Governance", "Vertical Integration"] },
                "Ethan Poskanzer": { method: "Quant/Mixed", keywords: ["Social Network Theory", "Entrepreneurship Theory", "Innovation & Inclusivity", "Entrepreneurial Networks"] }
            };

            // Helper to get expertise info for a reviewer (method + keywords)
            function getExpertiseInfo(reviewerName) {
                // Match by last name or full name
                for (const [name, info] of Object.entries(REVIEWER_EXPERTISE)) {
                    if (name.includes(reviewerName) || reviewerName.includes(name.split(' ').pop())) {
                        return info;
                    }
                }
                return null;
            }

            // Initialize Firebase
            firebase.initializeApp(firebaseConfig);
            const db = firebase.database();

            // Data
            let papers = [];
            let reviewers = [];
            let assignments = {};
            let reviews = {};
            let nominations = {}; // { reviewerId: paperId }
            let paperFiles = {};

            let dataLoaded = { papers: false, reviewers: false, assignments: false, reviews: false, paperFiles: false, nominations: false };

            const urlParams = new URLSearchParams(window.location.search);
            const reviewerId = urlParams.get('reviewer');
            const DEMO_MODE = urlParams.get('demo') === 'true';

            // =====================
            // ANONYMIZATION HELPERS (Demo Mode)
            // =====================
            // Consistent mapping for demo mode
            const demoNameMap = {};
            let demoCounter = 1;

            function getDisplayName(name) {
                if (!DEMO_MODE) return name;
                if (!name) return "Unknown";

                if (!demoNameMap[name]) {
                    demoNameMap[name] = `Reviewer ${String.fromCharCode(64 + demoCounter)}`; // Reviewer A, B, C...
                    demoCounter++;
                }
                return demoNameMap[name];
            }

            function getDisplayEmail(email) {
                if (!DEMO_MODE) return email;
                if (!email) return "";
                const randomId = Math.random().toString(36).substring(2, 6);
                return `reviewer_${randomId}@university.edu`;
            }

            // Init
            // Init
            document.getElementById('connection-status').textContent = 'Connected';
            document.getElementById('connection-status').className = 'connection-status connected';



            if (reviewerId) {
                showReviewerView(reviewerId);
            } else {
                document.getElementById('admin-login').classList.remove('hidden');
                document.getElementById('mode-badge').textContent = 'Admin Login';
            }

            setupDatabaseListeners();

            // =====================
            // DATABASE
            // =====================
            function checkAndRenderReviewerView() {
                if (reviewerId && dataLoaded.reviewers && dataLoaded.assignments && dataLoaded.papers && dataLoaded.reviews && dataLoaded.paperFiles) {
                    renderReviewerPapers(reviewerId);
                }
            }

            function migrateReviewerIdInReviews(oldId, newId) {
                db.ref('reviews').once('value', snap => {
                    const allReviews = snap.val() || {};
                    const updates = {};
                    let found = false;

                    Object.entries(allReviews).forEach(([paperId, paperReviews]) => {
                        if (paperReviews[oldId]) {
                            updates[`reviews/${paperId}/${newId}`] = paperReviews[oldId];
                            updates[`reviews/${paperId}/${oldId}`] = null;
                            found = true;
                        }
                    });

                    if (found) {
                        db.ref().update(updates);
                    }
                });
            }

            function setupDatabaseListeners() {
                db.ref('papers').on('value', (snapshot) => {
                    papers = snapshot.val() ? Object.values(snapshot.val()) : [];
                    dataLoaded.papers = true;
                    renderPapers();
                    renderAssignments();
                    renderResults();
                    checkAndRenderReviewerView();
                });

                db.ref('nominations').on('value', (snapshot) => {
                    nominations = snapshot.val() || {};
                    dataLoaded.nominations = true;
                    checkAllLoaded();
                    renderReviewers();
                    if (reviewerId) renderReviewerPapers(reviewerId);
                });

                db.ref('reviewers').on('value', (snapshot) => {
                    const rawReviewers = snapshot.val() || {};
                    reviewers = Object.values(rawReviewers);

                    // MIGRATION: Auto-convert old insecure IDs (R001, etc.) to Secure IDs if found
                    let migrationUpdates = {};
                    let hasMigration = false;

                    reviewers.forEach(r => {
                        if (r.id.startsWith('R') && !r.id.startsWith('REV-') && r.id.length <= 5) {
                            // Generate new secure ID
                            const newId = 'REV-' + Math.random().toString(36).substring(2, 8).toUpperCase();
                            const oldId = r.id;

                            // 1. Move reviewer data to new ID
                            migrationUpdates[`reviewers/${newId}`] = { ...r, id: newId };
                            migrationUpdates[`reviewers/${oldId}`] = null; // Delete old

                            // 2. Move assignments
                            if (assignments[oldId]) {
                                migrationUpdates[`assignments/${newId}`] = assignments[oldId];
                                migrationUpdates[`assignments/${oldId}`] = null;
                            }

                            // 3. Move reviews (nested under paperId)
                            // This is trickier as reviews are organized by paperId -> reviewerId
                            // We will handle reviews migration in the 'reviews' listener or separately
                            // For simplicity, we queue these ID mappings to handle reviews update
                            migrateReviewerIdInReviews(oldId, newId);

                            hasMigration = true;
                        }
                    });

                    if (hasMigration) {
                        console.log("Migrating insecure IDs...", migrationUpdates);
                        db.ref().update(migrationUpdates);
                        // Return early to let update propagate
                        return;
                    }

                    dataLoaded.reviewers = true;
                    renderReviewers();
                    renderReviewerWorkload();
                    renderReviewerLinks();
                    checkAndRenderReviewerView();
                });

                db.ref('assignments').on('value', (snapshot) => {
                    assignments = snapshot.val() || {};
                    dataLoaded.assignments = true;
                    renderAssignments();
                    renderReviewerWorkload();
                    renderReviewerLinks();
                    renderResults();
                    checkAndRenderReviewerView();
                });

                db.ref('reviews').on('value', (snapshot) => {
                    reviews = snapshot.val() || {};
                    dataLoaded.reviews = true;
                    renderResults();
                    checkAndRenderReviewerView();
                });

                db.ref('paperFiles').on('value', (snapshot) => {
                    paperFiles = snapshot.val() || {};
                    dataLoaded.paperFiles = true;
                    renderPapers();
                    checkAndRenderReviewerView();
                });
            }

            // =====================
            // AUTH & NAV
            // =====================

            // Listen for auth state
            firebase.auth().onAuthStateChanged(user => {
                // If in reviewer mode, ignore auth state updates to UI
                if (reviewerId) return;

                if (user) {
                    // Admin Logged In
                    document.getElementById('admin-login').classList.add('hidden');
                    document.getElementById('admin-view').classList.remove('hidden');
                    document.getElementById('mode-badge').textContent = 'Admin Mode';
                    setupTabNavigation();

                    // Add Sign Out Button if not present
                    if (!document.getElementById('sign-out-btn')) {
                        const header = document.querySelector('header');
                        const btn = document.createElement('button');
                        btn.id = 'sign-out-btn';
                        btn.innerText = 'Sign Out';
                        btn.className = 'btn-secondary btn-sm';
                        btn.style.position = 'absolute';
                        btn.style.top = '10px';
                        btn.style.left = '10px';
                        btn.onclick = () => firebase.auth().signOut();
                        header.appendChild(btn);
                    }
                } else {
                    // Logged Out
                    if (!reviewerId) {
                        document.getElementById('admin-login').classList.remove('hidden');
                        document.getElementById('admin-view').classList.add('hidden');
                        document.getElementById('mode-badge').textContent = 'Admin Login';
                    }
                    const btn = document.getElementById('sign-out-btn');
                    if (btn) btn.remove();
                }
            });

            function adminLogin() {
                const email = document.getElementById('login-email').value;
                const password = document.getElementById('login-password').value;
                const errorDiv = document.getElementById('auth-error');

                errorDiv.classList.add('hidden');

                if (!email || !password) {
                    return showToast('Please enter email and password');
                }

                firebase.auth().signInWithEmailAndPassword(email, password)
                    .catch((error) => {
                        console.error("Auth Error", error);
                        errorDiv.textContent = "Error: " + error.message;
                        errorDiv.classList.remove('hidden');

                        // Helpful hint for first time setup
                        if (error.code === 'auth/user-not-found' || error.code === 'auth/invalid-login-credentials') {
                            errorDiv.innerHTML += '<br><strong>Tip:</strong> Create this user in Firebase Console > Authentication > Users.';
                        }
                    });
            }

            function setupTabNavigation() {
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                        document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
                        tab.classList.add('active');
                        document.getElementById('tab-' + tab.dataset.tab).classList.remove('hidden');
                    });
                });
            }

            function showToast(msg) {
                const toast = document.getElementById('toast');
                toast.textContent = msg;
                toast.classList.add('show');
                setTimeout(() => toast.classList.remove('show'), 3000);
            }

            // =====================
            // PAPERS
            // =====================
            function addPaper() {
                const title = document.getElementById('paper-title').value.trim() || 'TBD';
                const pdfLink = document.getElementById('paper-pdf-link').value.trim();
                const keywords = document.getElementById('paper-keywords').value.trim();
                const abstract = document.getElementById('paper-abstract').value.trim();
                const paperId = 'P' + String(papers.length + 1).padStart(3, '0');

                const paperData = { id: paperId, title };
                if (keywords) paperData.keywords = keywords;
                if (abstract) paperData.abstract = abstract;

                db.ref('papers/' + paperId).set(paperData);
                if (pdfLink) db.ref('paperFiles/' + paperId).set({ link: pdfLink });

                document.getElementById('paper-title').value = '';
                document.getElementById('paper-pdf-link').value = '';
                document.getElementById('paper-keywords').value = '';
                document.getElementById('paper-abstract').value = '';
                showToast('Paper added: ' + paperId);
            }

            function renderPapers() {
                const container = document.getElementById('papers-list');
                if (!container) return;

                document.getElementById('paper-count').textContent = `(${papers.length})`;

                if (papers.length === 0) {
                    container.innerHTML = '<div class="empty-state"><p>No papers yet.</p></div>';
                    return;
                }

                container.innerHTML = `
                <div class="table-wrapper">
                    <table>
                        <thead><tr><th>ID</th><th>Title</th><th>PDF</th><th>Reviewers</th><th>Action</th></tr></thead>
                        <tbody>
                            ${papers.map(p => {
                    const revs = getReviewersForPaper(p.id);
                    const nomCount = Object.values(nominations).filter(n => n === p.id).length;
                    return `<tr>
                                    <td>${p.id}</td>
                                    <td>
                                        <div style="font-weight:500">
                                            ${(p.title || 'TBD').substring(0, 50)}...
                                            ${nomCount > 0 ? `<span class="nomination-badge" style="background:#fff3cd;color:#856404;padding:2px 6px;border-radius:10px;font-size:0.75rem;margin-left:6px;border:1px solid #ffeeba">üèÜ x${nomCount}</span>` : ''}
                                        </div>
                                        ${p.authors ? `<div style="font-size:0.75rem;color:var(--text-secondary);margin-top:2px">${p.authors.split(',')[0]} et al.</div>` : ''}
                                    </td>
                                    <td>${paperFiles[p.id]?.link ? '<span class="status status-has-file">‚úì</span>' : '-'}</td>
                                    <td>${revs.length}/2</td>
                                    <td>
                                        <button class="btn-secondary btn-sm" onclick="editPaper('${p.id}')">Edit</button>
                                        <button class="btn-danger btn-sm" onclick="removePaper('${p.id}')">√ó</button>
                                    </td>
                                </tr>`;
                }).join('')}
                        </tbody>
                    </table>
                </div>`;
            }

            function getReviewersForPaper(paperId) {
                const result = [];
                Object.entries(assignments).forEach(([revId, pids]) => {
                    // Only include assignments if the reviewer actually exists (prevents ghost IDs)
                    const isValid = reviewers.some(r => r.id === revId);
                    if (isValid && pids && pids.includes(paperId)) result.push(revId);
                });
                return result;
            }

            function editPaper(paperId) {
                const paper = papers.find(p => p.id === paperId);
                if (!paper) return;

                const newTitle = prompt('Paper title:', paper.title || 'TBD');
                if (newTitle !== null) db.ref('papers/' + paperId + '/title').set(newTitle);

                const newLink = prompt('PDF link:', paperFiles[paperId]?.link || '');
                if (newLink !== null) {
                    if (newLink.trim()) db.ref('paperFiles/' + paperId).set({ link: newLink.trim() });
                    else db.ref('paperFiles/' + paperId).remove();
                }
                showToast('Updated');
            }

            function removePaper(paperId) {
                if (!confirm('Remove ' + paperId + '?')) return;
                db.ref('papers/' + paperId).remove();
                db.ref('paperFiles/' + paperId).remove();
                Object.entries(assignments).forEach(([revId, pids]) => {
                    if (pids?.includes(paperId)) {
                        const updated = pids.filter(id => id !== paperId);
                        db.ref('assignments/' + revId).set(updated.length > 0 ? updated : null);
                    }
                });
                showToast('Removed');
            }

            function loadSamplePapers() {
                if (!confirm('Load 200 sample papers? These will be ADDED to the existing list.')) return;

                const baseTitles = [
                    "Dynamic Capabilities in Digital Platform Ecosystems",
                    "Alliance Portfolio Diversity and Innovation Performance",
                    "Corporate Political Activity in Emerging Markets",
                    "Knowledge Transfer in Cross-Border Acquisitions",
                    "Competitive Dynamics in Sharing Economy Markets",
                    "CEO Narcissism and Strategic Risk-Taking",
                    "Open Innovation and Appropriability Regimes",
                    "Institutional Voids and Multinational Strategy",
                    "Platform Governance and Ecosystem Health",
                    "Strategic Human Capital and Competitive Advantage",
                    "Digital Transformation and Organizational Ambidexterity",
                    "Stakeholder Orientation and Long-Term Value Creation"
                ];

                const baseKeywords = [
                    "quantitative, platform ecosystems, digital transformation, dynamic capabilities, competitive advantage",
                    "quantitative, alliance portfolios, innovation, strategic partnerships, diversification",
                    "mixed, corporate political activity, emerging markets, institutional theory, lobbying",
                    "qualitative, knowledge transfer, M&A, cross-border acquisitions, organizational learning",
                    "quantitative, sharing economy, competitive dynamics, platform competition, disruptive innovation",
                    "quantitative, CEO characteristics, risk-taking, narcissism, upper echelons",
                    "conceptual, open innovation, appropriability, intellectual property, knowledge spillovers",
                    "qualitative, institutional voids, multinational strategy, emerging markets, market entry",
                    "mixed, platform governance, ecosystem health, two-sided markets, network effects",
                    "quantitative, human capital, competitive advantage, talent management, strategic HR",
                    "mixed, digital transformation, ambidexterity, exploration, exploitation",
                    "conceptual, stakeholder theory, long-term value, corporate governance, sustainability"
                ];

                const baseAbstracts = [
                    "This study examines how firms develop and leverage dynamic capabilities within digital platform ecosystems. Using a multi-method approach combining quantitative analysis with case studies, we find that successful platform orchestrators develop sensing, seizing, and transforming capabilities that differ significantly from traditional hierarchical organizations.",
                    "We investigate the relationship between alliance portfolio diversity and innovation performance across 500 firms over a 10-year period. Our findings suggest that moderate levels of diversity optimize innovation outcomes, while excessive diversity leads to coordination costs that outweigh benefits.",
                    "This research explores corporate political activity strategies in emerging markets characterized by institutional voids. Through comparative case analysis of firms in Brazil, India, and China, we identify distinct political strategies that firms employ to navigate uncertain regulatory environments.",
                    "We examine knowledge transfer mechanisms in cross-border acquisitions, focusing on the role of organizational integration approaches. Our longitudinal study of 150 acquisitions reveals that hybrid integration strategies outperform both full integration and preservation approaches.",
                    "This paper analyzes competitive dynamics in sharing economy markets using game-theoretic models and empirical validation. We demonstrate that platform-based competitors face unique strategic challenges related to network effects and multi-homing behavior.",
                    "Drawing on upper echelons theory, we investigate how CEO narcissism influences strategic risk-taking decisions. Analysis of 300 CEO-firm dyads reveals that narcissistic CEOs pursue bolder strategies but also exhibit greater sensitivity to media attention.",
                    "This conceptual paper develops a framework for understanding the relationship between open innovation practices and appropriability regimes. We propose that firms must balance openness with protection mechanisms to capture value from collaborative innovation.",
                    "We explore how multinational corporations navigate institutional voids in emerging markets through qualitative research in Sub-Saharan Africa. Our findings highlight the importance of local partnerships and institutional entrepreneurship.",
                    "This study examines platform governance mechanisms and their impact on ecosystem health. Using data from 50 digital platforms, we identify governance practices that promote both platform growth and participant welfare.",
                    "We investigate strategic human capital investments and their contribution to sustainable competitive advantage. Our resource-based analysis reveals that firm-specific human capital creates more durable advantages than general human capital.",
                    "This research explores the organizational challenges of digital transformation through the lens of ambidexterity theory. Case studies of five incumbent firms reveal successful strategies for balancing exploration and exploitation.",
                    "We develop and test a stakeholder-oriented model of long-term value creation. Analysis of firm performance over 20 years demonstrates that balanced stakeholder management leads to superior long-term financial outcomes."
                ];

                const updates = {};
                const startIdx = papers.length;
                for (let i = 0; i < 200; i++) {
                    // Use 'D' prefix for Dummy/Demo data to avoid conflict with real 'P' papers
                    const id = 'D' + String(startIdx + i + 1).padStart(3, '0');
                    const idx = i % baseTitles.length;
                    const title = `${baseTitles[idx]} - Sample ${i + 1}`;
                    const keywords = baseKeywords[idx];
                    const abstract = baseAbstracts[idx];
                    updates['papers/' + id] = { id, title, keywords, abstract };
                    // Add sample PDF link for testing
                    updates['paperFiles/' + id] = { link: 'https://www.dropbox.com/scl/fi/o2kks05gvexd0gajm4e07/Aggarwal-V.-A.-Hsu-D.-H.-2014-.-Entrepreneurial-exit-and-innovation.pdf?rlkey=r4nr92j1q77cevoh2mzasczzr&dl=0' };
                }

                db.ref().update(updates);
                showToast('Added 200 sample papers');
            }

            function importFromCSV() {
                console.log("Import CSV clicked");
                const fileInput = document.getElementById('csv-file-input');
                const file = fileInput.files[0];

                if (!file) {
                    return showToast('Please select a CSV file first');
                }

                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        console.log("File read complete");
                        let text = e.target.result;
                        // Strip BOM if present
                        if (text.charCodeAt(0) === 0xFEFF) {
                            text = text.slice(1);
                        }

                        // Robust CSV Parsing to handle newlines inside quotes
                        function parseCSV(str) {
                            const arr = [];
                            let quote = false;
                            let col = 0, row = 0;

                            for (let c = 0; c < str.length; c++) {
                                let cc = str[c], nc = str[c + 1];
                                arr[row] = arr[row] || [];
                                arr[row][col] = arr[row][col] || '';

                                if (cc == '"' && quote && nc == '"') { arr[row][col] += cc; ++c; continue; }
                                if (cc == '"') { quote = !quote; continue; }
                                if (cc == ',' && !quote) { ++col; continue; }
                                if (cc == '\r' && nc == '\n' && !quote) { ++row; col = 0; ++c; continue; }
                                if (cc == '\n' && !quote) { ++row; col = 0; continue; }
                                if (cc == '\r' && !quote) { ++row; col = 0; continue; }

                                arr[row][col] += cc;
                            }
                            return arr;
                        }

                        const lines = parseCSV(text);

                        if (lines.length < 2) {
                            return showToast('CSV file is empty or has no data rows');
                        }

                        // Parse header
                        const header = lines[0].map(h => h.toLowerCase().trim().replace(/^"|"$/g, ''));
                        console.log("Header:", header);

                        const idIdx = header.indexOf('id');
                        const titleIdx = header.indexOf('title');
                        const linkIdx = header.indexOf('link');
                        const keywordIdx = header.indexOf('keywords');
                        const abstractIdx = header.indexOf('abstract');
                        const authorsIdx = Math.max(header.indexOf('authors'), header.indexOf('author'));
                        const affIdx = Math.max(header.indexOf('affiliations'), header.indexOf('affiliation'), header.indexOf('institution'));
                        const originalIdIdx = header.indexOf('original_id');

                        if (titleIdx === -1) {
                            return showToast('CSV must have a "title" column');
                        }

                        // Parse data rows
                        const updates = {};
                        let count = 0;
                        let maxIdNum = 0;

                        // Find max ID
                        papers.forEach(p => {
                            const match = p.id.match(/^P(\d+)$/);
                            if (match) {
                                const num = parseInt(match[1]);
                                if (num > maxIdNum) maxIdNum = num;
                            }
                        });

                        for (let i = 1; i < lines.length; i++) {
                            const row = lines[i];
                            // Skip empty rows or rows with too few columns (less than 2 is suspicious)
                            if (!row || row.length < 2 || (row.length === 1 && (!row[0] || !row[0].trim()))) continue;

                            let id = idIdx !== -1 && row[idIdx] ? row[idIdx].trim() : null;

                            // Safety Check: ID shouldn't be an abstract (long text)
                            if (id && (id.length > 20 || id.includes(' '))) {
                                console.warn("Invalid ID detected (too long/spaces), generating new one:", id.substring(0, 30));
                                id = null;
                            }

                            if (!id) {
                                maxIdNum++;
                                id = 'P' + String(maxIdNum).padStart(3, '0');
                            }

                            const title = titleIdx !== -1 && row[titleIdx] ? row[titleIdx].trim() : 'TBD';
                            if (title === 'TBD' && row.length > 1) {
                                // Simple row validation failed?
                            }
                            const link = linkIdx !== -1 && row[linkIdx] ? row[linkIdx].trim() : '';
                            const keywords = keywordIdx !== -1 && row[keywordIdx] ? row[keywordIdx].trim() : '';
                            const abstract = abstractIdx !== -1 && row[abstractIdx] ? row[abstractIdx].trim() : '';
                            const authors = authorsIdx !== -1 && row[authorsIdx] ? row[authorsIdx].trim() : '';
                            const affiliations = affIdx !== -1 && row[affIdx] ? row[affIdx].trim() : '';
                            const originalId = originalIdIdx !== -1 && row[originalIdIdx] ? row[originalIdIdx].trim() : '';

                            const paperData = { id, title, keywords, abstract };
                            if (authors) paperData.authors = authors;
                            if (affiliations) paperData.affiliations = affiliations;
                            if (originalId) paperData.originalId = originalId;

                            updates['papers/' + id] = paperData;
                            if (link) {
                                updates['paperFiles/' + id] = { link };
                            }
                            count++;
                        }

                        if (count === 0) {
                            return showToast('No valid papers found in CSV');
                        }

                        db.ref().update(updates);
                        showToast(`Imported ${count} papers`);
                        fileInput.value = '';
                    } catch (err) {
                        console.error("Import Error", err);
                        showToast("Error parsing CSV: " + err.message);
                    }
                };

                reader.onerror = function () {
                    showToast('Error reading file');
                };

                reader.readAsText(file);
            }

            function parseCSVLine(line) {
                // Simple CSV parser that handles quoted fields
                const result = [];
                let current = '';
                let inQuotes = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];

                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current);

                return result.map(s => s.replace(/^"|"$/g, '').trim());
            }

            function showPaperDetails(paperId) {
                const paper = papers.find(p => p.id === paperId);
                if (!paper) return;

                document.getElementById('modal-title').textContent = paper.title || 'TBD';
                document.getElementById('modal-id').textContent = paper.id;



                // Authors & Affiliations
                const authorsDiv = document.getElementById('modal-authors');
                const affDiv = document.getElementById('modal-affiliations');
                if (paper.authors) {
                    authorsDiv.textContent = paper.authors;
                    affDiv.textContent = paper.affiliations || '';
                    document.getElementById('modal-authors-section').style.display = 'block';
                } else {
                    document.getElementById('modal-authors-section').style.display = 'none';
                }

                // Keywords
                const kwContainer = document.getElementById('modal-keywords');
                kwContainer.innerHTML = '';
                if (paper.keywords) {
                    const keywords = paper.keywords.split(',').map(k => k.trim()).filter(k => k);
                    kwContainer.innerHTML = keywords.map(k => `<span class="keyword-tag">${k}</span>`).join('');
                } else {
                    kwContainer.innerHTML = '<span style="color:var(--text-secondary)">No keywords extracted</span>';
                }

                // Abstract/Details
                document.getElementById('modal-abstract').textContent = paper.abstract || 'Abstract not available. (Process papers with Python script to generate)';

                // Link
                const linkBtn = document.getElementById('modal-link');
                if (paperFiles[paperId]?.link) {
                    linkBtn.href = paperFiles[paperId].link;
                    linkBtn.style.display = 'inline-block';
                } else {
                    linkBtn.style.display = 'none';
                }

                document.getElementById('paper-modal').style.display = 'flex';
            }

            function closeModal(event) {
                if (event.target.id === 'paper-modal') {
                    document.getElementById('paper-modal').style.display = 'none';
                }
            }

            // =====================
            // REVIEWERS
            // =====================
            function addReviewer() {
                const name = document.getElementById('reviewer-name').value.trim();
                const email = document.getElementById('reviewer-email').value.trim();
                const maxPapers = document.getElementById('reviewer-max').value.trim();
                const expertise = document.getElementById('reviewer-expertise').value.trim();

                if (!name || !email) return showToast('Name and email required');

                // Generate secure random ID (8 chars)
                const randomId = Math.random().toString(36).substring(2, 10).toUpperCase();
                const id = 'REV-' + randomId;

                db.ref('reviewers/' + id).set({
                    id, name, email,
                    maxPapers: maxPapers ? parseInt(maxPapers) : null,
                    expertise: expertise || null
                });

                document.getElementById('reviewer-name').value = '';
                document.getElementById('reviewer-email').value = '';
                document.getElementById('reviewer-max').value = '';
                document.getElementById('reviewer-expertise').value = '';
                showToast('Reviewer added with Secure ID');
            }

            function loadDefaultReviewers() {
                const list = [
                    { name: "Janet Lee Elsie Bercovitz", email: "Janet.Bercovitz@Colorado.EDU" },
                    { name: "Danielle Bovenberg", email: "Danielle.Bovenberg@colorado.edu" },
                    { name: "Mukund Chari", email: "Mukund.Chari@Colorado.EDU" },
                    { name: "Ashton Lewis Hawk", email: "Ashton.Hawk@Colorado.EDU" },
                    { name: "Sina Sokhan", email: "sina@colorado.edu" },
                    { name: "MJ Yang", email: "MJ.Yang@colorado.edu" },
                    { name: "Kenneth Huang", email: "kennethhuang@nus.edu.sg" },
                    { name: "Aldona Kapacinskaite", email: "aldona.kapacinskaite@insead.edu" },
                    { name: "Wesley W. Koo", email: "wesley.koo@jhu.edu" },
                    { name: "Catherine Magelssen", email: "catherine.magelssen@moore.sc.edu" },
                    { name: "Anparasan Mahalingam", email: "amahalin@syr.edu" },
                    { name: "Francisco Morales", email: "fjmorales@uandes.cl" },
                    { name: "Metin Sengul", email: "metin.sengul@mccombs.utexas.edu" },
                    { name: "Xiaoli Tang", email: "xtang1@bu.edu" },
                    { name: "Andy Wu", email: "awu@hbs.edu" },
                    { name: "Mingtao Xu", email: "xumt@sem.tsinghua.edu.cn" },
                    { name: "Tony Tong", email: "tony.tong@colorado.edu" },
                    { name: "Yuchen Zhang", email: "yzhang54@tulane.edu" },
                    { name: "Ethan Poskanzer", email: "Ethan.Poskanzer@Colorado.edu" }
                ];

                const updates = {};
                list.forEach((r, i) => {
                    // Use secure REV- IDs directly to avoid migration loop
                    const id = 'REV-' + Math.random().toString(36).substring(2, 10).toUpperCase();

                    // Set max papers limit for specific reviewers
                    let maxPapers = null;
                    if (r.name === "Janet Lee Elsie Bercovitz" || r.name === "Ethan Poskanzer") {
                        maxPapers = 10;
                    }

                    updates[id] = { id, ...r, maxPapers: maxPapers, expertise: null };
                });
                db.ref('reviewers').set(updates);
                showToast('Loaded 19 reviewers');
            }

            function renderReviewers() {
                const container = document.getElementById('reviewers-list');
                if (!container) return;

                document.getElementById('reviewer-count').textContent = `(${reviewers.length})`;

                if (reviewers.length === 0) {
                    container.innerHTML = '<div class="empty-state"><p>No reviewers yet.</p></div>';
                    return;
                }

                container.innerHTML = `
                <div class="table-wrapper">
                    <table>
                        <thead><tr><th>Name</th><th>Email</th><th>Max</th><th>Expertise</th><th>Action</th></tr></thead>
                        <tbody>
                            ${reviewers.map(r => {
                    const displayName = getDisplayName(r.name);
                    const displayEmail = getDisplayEmail(r.email);
                    const info = getExpertiseInfo(r.name);
                    let expertiseHtml = r.expertise || '-';
                    if (info) {
                        const methodTag = `<span class="method-tag">${info.method}</span>`;
                        const keywordTags = info.keywords.slice(0, 3).map(k => `<span class="expertise-tag">${k}</span>`).join('');
                        expertiseHtml = methodTag + keywordTags;
                    }
                    return `<tr>
                                <td>${displayName}</td>
                                <td style="font-size:0.8rem">${displayEmail}</td>
                                <td>${r.maxPapers || '‚àû'}</td>
                                <td style="font-size:0.8rem;max-width:350px;">${expertiseHtml}</td>
                                <td>
                                    <button class="btn-secondary btn-sm" onclick="editReviewer('${r.id}')">Edit</button>
                                    <button class="btn-danger btn-sm" onclick="removeReviewer('${r.id}')">√ó</button>
                                </td>
                            </tr>`;
                }).join('')}
                        </tbody>
                    </table>
                </div>`;
            }

            function editReviewer(id) {
                const r = reviewers.find(x => x.id === id);
                if (!r) return;

                const max = prompt('Max papers (empty = no limit):', r.maxPapers || '');
                if (max !== null) db.ref('reviewers/' + id + '/maxPapers').set(max ? parseInt(max) : null);

                const exp = prompt('Expertise:', r.expertise || '');
                if (exp !== null) db.ref('reviewers/' + id + '/expertise').set(exp || null);

                showToast('Updated');
            }

            function removeReviewer(id) {
                if (!confirm('Remove reviewer?')) return;
                db.ref('reviewers/' + id).remove();
                db.ref('assignments/' + id).remove();
                showToast('Removed');
            }

            // =====================
            // ASSIGNMENTS
            // =====================
            function getReviewerPaperCount(revId) {
                return (assignments[revId] || []).length;
            }

            function renderAssignments() {
                const container = document.getElementById('assignments-list');
                if (!container) return;

                if (papers.length === 0) {
                    container.innerHTML = '<div class="empty-state"><p>Add papers first.</p></div>';
                    return;
                }

                const filter = document.getElementById('filter-assignment-status')?.value || 'all';
                let filtered = papers;
                if (filter === 'incomplete') filtered = papers.filter(p => getReviewersForPaper(p.id).length < 2);
                else if (filter === 'complete') filtered = papers.filter(p => getReviewersForPaper(p.id).length >= 2);

                container.innerHTML = filtered.map(paper => {
                    const assigned = getReviewersForPaper(paper.id);
                    const isComplete = assigned.length >= 2;
                    const available = reviewers.filter(r => {
                        if (assigned.includes(r.id)) return false;
                        if (r.maxPapers && getReviewerPaperCount(r.id) >= r.maxPapers) return false;
                        return true;
                    });

                    return `
                    <div class="assignment-paper ${isComplete ? 'complete' : ''}">
                        <div style="display:flex;justify-content:space-between;align-items:start;flex-wrap:wrap;gap:12px">
                            <div>
                                <strong>
                                    <button class="info-btn" onclick="showPaperDetails('${paper.id}')">‚ÑπÔ∏è</button>
                                    ${paper.id}
                                </strong>: ${(paper.title || 'TBD').substring(0, 45)}
                                <div style="margin-top:8px">
                                    ${assigned.map(rid => {
                        const rev = reviewers.find(r => r.id === rid);
                        const displayName = rev ? getDisplayName(rev.name) : rid;
                        return `<span class="reviewer-tag">${displayName}<span class="remove" onclick="unassign('${paper.id}','${rid}')">√ó</span></span>`;
                    }).join('')}
                                    ${!isComplete ? `<span style="color:var(--warning);font-size:0.8rem">Need ${2 - assigned.length} more</span>` : ''}
                                </div>
                            </div>
                            <select onchange="assign('${paper.id}',this.value);this.value=''" style="min-width:180px">
                                <option value="">+ Add reviewer</option>
                                ${reviewers.map(r => {
                        const displayName = getDisplayName(r.name);
                        const alreadyAssigned = assigned.includes(r.id);
                        const atCapacity = r.maxPapers && getReviewerPaperCount(r.id) >= r.maxPapers;
                        const disabled = alreadyAssigned || atCapacity;
                        const status = alreadyAssigned ? ' [assigned]' : atCapacity ? ' [full]' : '';
                        return `<option value="${r.id}" ${disabled ? 'disabled' : ''}>${displayName} (${getReviewerPaperCount(r.id)}${r.maxPapers ? '/' + r.maxPapers : ''})${status}</option>`;
                    }).join('')}
                            </select>
                        </div>
                    </div>`;
                }).join('');
            }

            function assign(paperId, revId) {
                if (!revId) return;

                // Check paper limit (max 2)
                const currentAssigns = getReviewersForPaper(paperId);
                if (currentAssigns.length >= 2) {
                    return showToast('Paper already has 2 reviewers');
                }

                // Check reviewer limit
                const r = reviewers.find(x => x.id === revId);
                const rCount = getReviewerPaperCount(revId);
                if (r.maxPapers && rCount >= r.maxPapers) {
                    return showToast('Reviewer is at max capacity');
                }

                const current = assignments[revId] || [];
                if (!current.includes(paperId)) {
                    current.push(paperId);
                    db.ref('assignments/' + revId).set(current);
                    showToast('Assigned');
                }
            }

            function generateRandomAssignments() {
                if (!confirm('This will attempt to assign 2 reviewers to every paper based on availability. Existing assignments are kept. Continue?')) return;

                let updates = {};
                let madeChanges = false;

                // Clone current assignments to track locally during generation
                let tempAssignments = JSON.parse(JSON.stringify(assignments));

                // Helper to get local count
                const getLocalCount = (rid) => (tempAssignments[rid] || []).length;
                const getLocalPaperAssigns = (pid) => {
                    const res = [];
                    Object.entries(tempAssignments).forEach(([rid, list]) => {
                        if (list.includes(pid)) res.push(rid);
                    });
                    return res;
                };

                // Shuffle arrays
                const shuffledPapers = [...papers].sort(() => 0.5 - Math.random());

                shuffledPapers.forEach(p => {
                    const current = getLocalPaperAssigns(p.id);
                    if (current.length >= 2) return; // Already full

                    const needed = 2 - current.length;

                    // Find eligible reviewers
                    const eligible = reviewers
                        .filter(r => {
                            // Not already assigned to this paper
                            if (current.includes(r.id)) return false;
                            // Has capacity
                            if (r.maxPapers && getLocalCount(r.id) >= r.maxPapers) return false;
                            return true;
                        })
                        .sort(() => 0.5 - Math.random()); // Shuffle reviewers

                    // Assign up to 'needed' amount
                    for (let i = 0; i < needed && i < eligible.length; i++) {
                        const r = eligible[i];
                        if (!tempAssignments[r.id]) tempAssignments[r.id] = [];
                        tempAssignments[r.id].push(p.id);
                        updates[r.id] = tempAssignments[r.id];
                        madeChanges = true;
                    }
                });

                if (madeChanges) {
                    db.ref('assignments').update(updates);
                    showToast('Random assignments generated');
                } else {
                    showToast('No new assignments possible (check capacity)');
                }
            }
            function unassign(paperId, revId) {
                const current = assignments[revId] || [];
                const updated = current.filter(id => id !== paperId);
                db.ref('assignments/' + revId).set(updated.length > 0 ? updated : null);
                showToast('Unassigned');
            }

            function clearAssignments() {
                if (!confirm('Are you sure you want to remove ALL assignments? This cannot be undone.')) return;

                db.ref('assignments').remove()
                    .then(() => {
                        assignments = {};
                        renderAssignments();
                        renderReviewerWorkload();
                        showToast('All assignments cleared');
                    })
                    .catch(err => showToast('Error: ' + err.message));
            }


            function checkAllLoaded() {
                if (Object.values(dataLoaded).every(Boolean)) {
                    document.getElementById('loading').classList.add('hidden');
                    if (!reviewerId) {
                        try {
                            renderReviewers();
                            renderAssignments();
                            renderReviewerWorkload();
                        } catch (e) { console.error("Render error", e); }
                    } else {
                        renderReviewerPapers(reviewerId);
                    }
                }
            }

            function importAssignmentsCSV() {
                const fileInput = document.getElementById('assignments-csv-input');
                const file = fileInput.files[0];

                if (!file) {
                    return showToast('Please select a CSV file first');
                }

                if (reviewers.length === 0) {
                    return showToast('Please load reviewers first');
                }

                const reader = new FileReader();
                reader.onload = function (e) {
                    const text = e.target.result;
                    const lines = text.split('\n').filter(line => line.trim());

                    if (lines.length < 2) {
                        return showToast('CSV file is empty or has no data rows');
                    }

                    // Parse header
                    const header = parseCSVLine(lines[0]).map(h => h.toLowerCase().trim());
                    const paperIdIdx = header.findIndex(h => h.includes('paper') && h.includes('id'));
                    const rev1Idx = header.findIndex(h => h.includes('reviewer') && h.includes('1'));
                    const rev2Idx = header.findIndex(h => h.includes('reviewer') && h.includes('2'));

                    if (paperIdIdx === -1) {
                        return showToast('CSV must have a "paper_id" column');
                    }

                    // Helper to find reviewer ID by name
                    function findReviewerId(name) {
                        if (!name || !name.trim()) return null;
                        const cleanName = name.trim().toLowerCase();
                        // Try exact match first
                        let match = reviewers.find(r => r.name.toLowerCase() === cleanName);
                        if (match) return match.id;
                        // Try partial match (last name)
                        match = reviewers.find(r => {
                            const lastName = r.name.split(' ').pop().toLowerCase();
                            return cleanName.includes(lastName) || lastName.includes(cleanName);
                        });
                        if (match) return match.id;
                        // Try first name
                        match = reviewers.find(r => {
                            const firstName = r.name.split(' ')[0].toLowerCase();
                            return cleanName.includes(firstName);
                        });
                        return match ? match.id : null;
                    }

                    // Build assignments object
                    const newAssignments = {};
                    let importedCount = 0;
                    let skippedCount = 0;

                    for (let i = 1; i < lines.length; i++) {
                        const row = parseCSVLine(lines[i]);
                        if (row.length === 0) continue;

                        const paperId = row[paperIdIdx]?.trim();
                        if (!paperId) continue;

                        // Check if paper exists
                        const paperExists = papers.some(p => p.id === paperId);
                        if (!paperExists) {
                            console.log(`Skipping unknown paper: ${paperId}`);
                            skippedCount++;
                            continue;
                        }

                        const rev1Name = rev1Idx !== -1 ? row[rev1Idx]?.trim() : null;
                        const rev2Name = rev2Idx !== -1 ? row[rev2Idx]?.trim() : null;

                        const rev1Id = findReviewerId(rev1Name);
                        const rev2Id = findReviewerId(rev2Name);

                        if (rev1Id) {
                            if (!newAssignments[rev1Id]) newAssignments[rev1Id] = [];
                            if (!newAssignments[rev1Id].includes(paperId)) {
                                newAssignments[rev1Id].push(paperId);
                            }
                        }
                        if (rev2Id) {
                            if (!newAssignments[rev2Id]) newAssignments[rev2Id] = [];
                            if (!newAssignments[rev2Id].includes(paperId)) {
                                newAssignments[rev2Id].push(paperId);
                            }
                        }

                        if (rev1Id || rev2Id) importedCount++;
                    }

                    if (importedCount === 0) {
                        return showToast('No valid assignments found in CSV');
                    }

                    // Merge with existing or replace?
                    const shouldMerge = confirm(`Found ${importedCount} papers with assignments.\n\nClick OK to MERGE with existing assignments.\nClick Cancel to REPLACE all assignments.`);

                    if (shouldMerge) {
                        // Merge: add new assignments to existing
                        Object.entries(newAssignments).forEach(([revId, paperIds]) => {
                            const existing = assignments[revId] || [];
                            const merged = [...new Set([...existing, ...paperIds])];
                            newAssignments[revId] = merged;
                        });
                        // Keep existing reviewer assignments not in import
                        Object.entries(assignments).forEach(([revId, paperIds]) => {
                            if (!newAssignments[revId]) {
                                newAssignments[revId] = paperIds;
                            }
                        });
                    }

                    db.ref('assignments').set(newAssignments)
                        .then(() => {
                            showToast(`Imported assignments for ${importedCount} papers` + (skippedCount > 0 ? ` (${skippedCount} skipped)` : ''));
                            fileInput.value = '';
                        })
                        .catch(err => showToast('Error: ' + err.message));
                };

                reader.onerror = function () {
                    showToast('Error reading file');
                };

                reader.readAsText(file);
            }

            function renderReviewerWorkload() {
                const container = document.getElementById('reviewer-workload');
                if (!container) return;

                if (reviewers.length === 0) {
                    container.innerHTML = '<div class="empty-state"><p>Add reviewers first.</p></div>';
                    return;
                }

                container.innerHTML = `
                <div class="table-wrapper">
                    <table>
                        <thead><tr><th>Reviewer</th><th>Expertise</th><th>Assigned</th><th>Capacity</th></tr></thead>
                        <tbody>
                            ${reviewers.map(r => {
                    const displayName = getDisplayName(r.name);
                    const info = getExpertiseInfo(r.name);
                    let expertiseHtml = r.expertise || '-';
                    if (info) {
                        const methodTag = `<span class="method-tag">${info.method}</span>`;
                        const keywordTags = info.keywords.slice(0, 3).map(k => `<span class="expertise-tag">${k}</span>`).join('');
                        expertiseHtml = methodTag + keywordTags;
                    }

                    const count = getReviewerPaperCount(r.id);
                    const max = r.maxPapers || 999;
                    const pct = Math.min(100, (count / max) * 100);
                    const full = r.maxPapers && count >= r.maxPapers;
                    return `<tr>
                                    <td>${displayName}</td>
                                    <td style="font-size:0.8rem;max-width:350px;">${expertiseHtml}</td>
                                    <td>${count}</td>
                                    <td style="width:120px">
                                        ${r.maxPapers ? `
                                            <div class="capacity-bar"><div class="capacity-fill ${full ? 'full' : ''}" style="width:${pct}%"></div></div>
                                            <span style="font-size:0.75rem;color:var(--text-secondary)">${count}/${r.maxPapers}</span>
                                        ` : '<span style="font-size:0.8rem;color:var(--text-secondary)">No limit</span>'}
                                    </td>
                                </tr>`;
                }).join('')}
                        </tbody>
                    </table>
                </div>`;
            }

            function renderReviewerLinks() {
                const container = document.getElementById('reviewer-links');
                if (!container) return;

                const withAssignments = reviewers.filter(r => (assignments[r.id] || []).length > 0);

                if (withAssignments.length === 0) {
                    container.innerHTML = '<div class="empty-state"><p>Assign papers first.</p></div>';
                    return;
                }

                const baseUrl = window.location.origin + window.location.pathname;

                container.innerHTML = `
                <div class="alert ${TEST_MODE ? 'alert-warning' : 'alert-info'}" style="margin-bottom:16px">
                    ${TEST_MODE ? '<strong>‚ö†Ô∏è TEST MODE:</strong> All emails will be sent to ' + TEST_EMAIL + ' for testing.' : '<strong>Tip:</strong> Click "Send Email" to open your email client with a pre-filled message.'}
                </div>
                <button class="btn-secondary" style="margin-bottom:16px" onclick="copyAllLinks()">Copy All Links</button>
                <button class="btn-primary" style="margin-bottom:16px;margin-left:8px" onclick="sendAllEmails()">üìß Send All Emails</button>
                ${withAssignments.map(r => {
                    const displayName = getDisplayName(r.name);
                    const link = `${baseUrl}?reviewer=${r.id}`;
                    const count = (assignments[r.id] || []).length;
                    return `
                        <div style="margin-bottom:12px;padding:16px;border:1px solid var(--border);border-radius:8px;background:#fff">
                            <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px">
                                <div>
                                    <strong style="color:#1a1a1a">${displayName}</strong>
                                    <span style="color:#666;margin-left:8px">(${count} papers)</span>
                                </div>
                                <div>
                                    <button class="btn-secondary btn-sm" onclick="copyLink('${link}')">üìã Copy</button>
                                    <button class="btn-primary btn-sm" style="margin-left:4px" onclick="sendEmail('${r.id}')">üìß Email</button>
                                </div>
                            </div>
                            <div class="link-box" style="margin-top:10px;font-size:0.85rem">${link}</div>
                        </div>`;
                }).join('')}`;
            }

            function copyLink(link) {
                navigator.clipboard.writeText(link);
                showToast('Copied');
            }

            function getEmailTemplate(reviewer, link, paperCount) {
                const subject = `Strategy Science Conference 2026 - Review Assignment`;

                // Extract surname (last word of the name)
                const reviewerName = getDisplayName(reviewer.name);
                const nameParts = reviewerName.trim().split(' ');
                const surname = nameParts[nameParts.length - 1];

                const body = `Dear Professor ${surname},

Thank you for serving on the Scientific Committee of the 2026 Strategy Science Conference. We appreciate your time and expertise in helping us select high-quality papers for the Conference program.

You have been assigned ${paperCount} papers for review. Please access your personal review portal using the link below:

${link}

We kindly ask that you complete your reviews by February 20, 2026.

For each paper, please provide a recommendation using the following scale. You will simply click on one of the four buttons listed below each paper.
- No: Strong reject
- Maybe No: Weak reject
- Maybe Yes: Weak accept
- Yes: Strong accept

Please note that once you click a button, your review is recorded; you may, however, return to the system at any time to change your rating if needed.  There is not a separate submission button.

In addition, the system will ask you to nominate one paper from your assigned set for consideration for the Conference Best Paper Award, using a simple Yes/No button below each paper.

Should you have any questions or encounter any issues with the portal, please feel free to contact me at tony.tong@colorado.edu

Warm regards,

Tony Tong

On behalf of the 2026 SSC Organizing Committee`;

                return { subject, body };
            }

            function sendEmail(reviewerId) {
                const reviewer = reviewers.find(r => r.id === reviewerId);
                if (!reviewer) return showToast('Reviewer not found');

                const baseUrl = window.location.origin + window.location.pathname;
                const link = `${baseUrl}?reviewer=${reviewer.id}`;
                const paperCount = (assignments[reviewer.id] || []).length;

                const { subject, body } = getEmailTemplate(reviewer, link, paperCount);

                // In test mode, send to test email instead
                const toEmail = TEST_MODE ? TEST_EMAIL : reviewer.email;
                const mailtoUrl = `mailto:${toEmail}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;

                window.open(mailtoUrl, '_blank');

                if (TEST_MODE) {
                    showToast(`Test email opened (to: ${TEST_EMAIL})`);
                } else {
                    showToast(`Email opened for ${reviewer.name}`);
                }
            }

            function sendAllEmails() {
                const withAssignments = reviewers.filter(r => (assignments[r.id] || []).length > 0);

                if (withAssignments.length === 0) {
                    return showToast('No reviewers with assignments');
                }

                if (TEST_MODE) {
                    alert(`TEST MODE: This will open ${withAssignments.length} email window(s), all addressed to ${TEST_EMAIL}.\n\nIn production mode, emails would be sent to actual reviewer addresses.`);
                } else {
                    if (!confirm(`This will open ${withAssignments.length} email windows. Continue?`)) return;
                }

                // Open emails with a small delay to prevent browser blocking
                withAssignments.forEach((r, index) => {
                    setTimeout(() => {
                        sendEmail(r.id);
                    }, index * 500);
                });
            }

            function copyAllLinks() {
                const baseUrl = window.location.origin + window.location.pathname;
                const text = reviewers.filter(r => (assignments[r.id] || []).length > 0)
                    .map(r => `${r.name}\nEmail: ${r.email}\nPapers: ${(assignments[r.id] || []).join(', ')}\nLink: ${baseUrl}?reviewer=${r.id}`)
                    .join('\n\n---\n\n');
                navigator.clipboard.writeText(text);
                showToast('All links copied');
            }

            // =====================
            // RESULTS
            // =====================

            function performDemoReview() {
                if (!confirm('This will assign RANDOM scores to all currently assigned papers. Existing scores will be overwritten. Continue?')) {
                    return;
                }

                const updates = {};
                let count = 0;

                const decisions = ['no', 'maybe-no', 'maybe-yes', 'yes'];

                for (const [revId, assignedPapers] of Object.entries(assignments)) {
                    if (!assignedPapers) continue;

                    let nominated = false;
                    assignedPapers.forEach(paperId => {
                        const randomDecision = decisions[Math.floor(Math.random() * decisions.length)];
                        updates[`reviews/${paperId}/${revId}`] = {
                            decision: randomDecision,
                            timestamp: firebase.database.ServerValue.TIMESTAMP
                        };
                        count++;
                    });

                    // Randomly nominate one paper (50% chance)
                    if (assignedPapers.length > 0 && Math.random() > 0.5) {
                        const randomPaper = assignedPapers[Math.floor(Math.random() * assignedPapers.length)];
                        updates[`nominations/${revId}`] = randomPaper;
                    }
                }

                if (count === 0) {
                    return showToast('No assignments found to review.');
                }

                db.ref().update(updates);
                showToast(`Auto-reviewed ${count} assignments!`);
            }

            // Store admin judgments (persisted in Firebase)
            let adminJudgments = {};

            // Load admin judgments from Firebase
            db.ref('adminJudgments').on('value', snap => {
                adminJudgments = snap.val() || {};
                if (dataLoaded.papers) renderResults();
            });

            function calcScore(paperId) {
                const pr = reviews[paperId] || {};
                const entries = Object.entries(pr);
                if (entries.length === 0) return { score: null, count: 0, details: [], hasConflict: false, pairType: null, priority: 0 };

                let total = 0;
                const details = [];
                entries.forEach(([revId, r]) => {
                    const s = SCORE_MAP[r.decision] || 0;
                    total += s;
                    const reviewer = reviewers.find(rev => rev.id === revId);
                    details.push({
                        decision: r.decision,
                        score: s,
                        reviewerId: revId,
                        reviewerName: reviewer ? getDisplayName(reviewer.name) : revId
                    });
                });

                // Check for conflict: yes+no OR maybe-yes+maybe-no
                const decisions = details.map(d => d.decision);
                const hasConflict = (decisions.includes('yes') && decisions.includes('no')) ||
                    (decisions.includes('maybe-yes') && decisions.includes('maybe-no'));

                // Determine pair type and priority for ordering
                // Priority: Yes+No (conflict) > Yes+Yes > Yes+MaybeYes > etc.
                // Higher priority = higher in list when same score
                let pairType = null;
                let priority = 0;

                if (details.length >= 2) {
                    const sorted = [...decisions].sort();
                    pairType = sorted.join(' + ');

                    // Priority mapping: pairs with strong opinions rank higher
                    const pairPriority = {
                        'no + yes': 100,           // Conflict - highest priority
                        'yes + yes': 90,           // Strong accept
                        'no + no': 85,             // Strong reject
                        'maybe-yes + yes': 70,     // Leaning accept
                        'no + maybe-no': 65,       // Leaning reject
                        'maybe-no + yes': 60,
                        'no + maybe-yes': 55,
                        'maybe-yes + maybe-yes': 50,  // Moderate accept
                        'maybe-no + maybe-no': 45,    // Moderate reject
                        'maybe-no + maybe-yes': 95    // Conflict (weak) - High priority
                    };
                    priority = pairPriority[pairType] || 30;
                }

                return { score: total, count: entries.length, details, hasConflict, pairType, priority };
            }

            function getPairLabel(pairType) {
                const labels = {
                    'yes + yes': 'Yes + Yes',
                    'maybe-yes + yes': 'Yes + Maybe Yes',
                    'maybe-yes + maybe-yes': 'Maybe Yes + Maybe Yes',
                    'maybe-no + maybe-yes': 'Maybe Yes + Maybe No (Conflict)',
                    'maybe-no + maybe-no': 'Maybe No + Maybe No',
                    'no + maybe-no': 'No + Maybe No',
                    'no + no': 'No + No',
                    'no + yes': 'Yes + No (Conflict)',
                    'maybe-no + yes': 'Yes + Maybe No',
                    'no + maybe-yes': 'No + Maybe Yes'
                };
                return labels[pairType] || pairType || 'Incomplete';
            }

            function setAdminJudgment(paperId, judgment) {
                if (judgment === '') {
                    db.ref(`adminJudgments/${paperId}`).remove();
                } else {
                    db.ref(`adminJudgments/${paperId}`).set(judgment);
                }
            }

            function applyDefaultJudgments() {
                const cutoff = parseInt(document.getElementById('cutoff-number')?.value) || 0;

                // If cutoff is 0, clear all judgments
                if (cutoff === 0) {
                    adminJudgments = {};
                    db.ref('adminJudgments').remove();
                    return;
                }

                const scores = papers.map(p => ({ ...p, ...calcScore(p.id) }));
                scores.sort((a, b) => {
                    if (a.score === null && b.score === null) return 0;
                    if (a.score === null) return 1;
                    if (b.score === null) return -1;
                    if (b.score !== a.score) return b.score - a.score;
                    return b.priority - a.priority;
                });

                // Build new judgments object from scratch
                const newJudgments = {};
                scores.forEach((p, i) => {
                    const rank = i + 1;
                    // Skip conflicts - they need manual review
                    if (p.hasConflict) {
                        // Preserve existing judgment for conflicts if any
                        if (adminJudgments[p.id]) {
                            newJudgments[p.id] = adminJudgments[p.id];
                        }
                        return;
                    }
                    newJudgments[p.id] = rank <= cutoff ? 'accepted' : 'rejected';
                });

                // Replace entire object to ensure consistency
                adminJudgments = newJudgments;
                db.ref('adminJudgments').set(newJudgments);
            }

            function renderResults() {
                const totalPapers = papers.length;
                let reviewed = 0, pending = 0, conflictCount = 0;

                const scores = papers.map(p => {
                    const s = calcScore(p.id);
                    if (s.count >= 2) reviewed++;
                    else pending++;
                    if (s.hasConflict) conflictCount++; // Count conflicts
                    return { ...p, ...s };
                });

                document.getElementById('stat-total-papers').textContent = totalPapers;
                document.getElementById('stat-reviewed').textContent = reviewed;
                document.getElementById('stat-pending').textContent = pending;
                document.getElementById('stat-avg-score').textContent = conflictCount; // Display conflicts

                const container = document.getElementById('results-list');
                if (!container) return;

                const cutoff = parseInt(document.getElementById('cutoff-number')?.value) || 0;
                const filter = document.getElementById('conflict-filter')?.value || 'all';
                const sortOrder = document.getElementById('sort-order')?.value || 'score';

                // Sort based on selected order
                if (sortOrder === 'accepted-first') {
                    scores.sort((a, b) => {
                        const aAccepted = adminJudgments[a.id] === 'accepted' ? 1 : 0;
                        const bAccepted = adminJudgments[b.id] === 'accepted' ? 1 : 0;
                        if (bAccepted !== aAccepted) return bAccepted - aAccepted;
                        // Secondary sort by score
                        if (a.score === null && b.score === null) return 0;
                        if (a.score === null) return 1;
                        if (b.score === null) return -1;
                        return b.score - a.score;
                    });
                } else if (sortOrder === 'waitlisted-first') {
                    scores.sort((a, b) => {
                        const aWaitlisted = adminJudgments[a.id] === 'waitlisted' ? 1 : 0;
                        const bWaitlisted = adminJudgments[b.id] === 'waitlisted' ? 1 : 0;
                        if (bWaitlisted !== aWaitlisted) return bWaitlisted - aWaitlisted;
                        // Secondary sort by score
                        if (a.score === null && b.score === null) return 0;
                        if (a.score === null) return 1;
                        if (b.score === null) return -1;
                        return b.score - a.score;
                    });
                } else if (sortOrder === 'rejected-first') {
                    scores.sort((a, b) => {
                        const aRejected = adminJudgments[a.id] === 'rejected' ? 1 : 0;
                        const bRejected = adminJudgments[b.id] === 'rejected' ? 1 : 0;
                        if (bRejected !== aRejected) return bRejected - aRejected;
                        // Secondary sort by score
                        if (a.score === null && b.score === null) return 0;
                        if (a.score === null) return 1;
                        if (b.score === null) return -1;
                        return b.score - a.score;
                    });
                } else {
                    // Default: sort by score, then by priority
                    scores.sort((a, b) => {
                        if (a.score === null && b.score === null) return 0;
                        if (a.score === null) return 1;
                        if (b.score === null) return -1;
                        if (b.score !== a.score) return b.score - a.score;
                        return b.priority - a.priority;
                    });
                }

                // Apply filter
                let filteredScores = scores;
                if (filter === 'conflicts') {
                    filteredScores = scores.filter(p => p.hasConflict);
                } else if (filter === 'nominated') {
                    filteredScores = scores.filter(p => {
                        const nomCount = Object.values(nominations).filter(n => n === p.id).length;
                        return nomCount > 0;
                    });
                } else if (filter === 'accepted') {
                    filteredScores = scores.filter(p => adminJudgments[p.id] === 'accepted');
                } else if (filter === 'waitlisted') {
                    filteredScores = scores.filter(p => adminJudgments[p.id] === 'waitlisted');
                } else if (filter === 'rejected') {
                    filteredScores = scores.filter(p => adminJudgments[p.id] === 'rejected');
                } else if (filter === 'pending') {
                    filteredScores = scores.filter(p => !adminJudgments[p.id]);
                }

                const badge = (d) => {
                    if (!d) return '<span class="status status-pending">Pending</span>';
                    const tooltip = d.reviewerName ? `title="${d.reviewerName}"` : '';
                    return `<span class="status status-${d.decision}" ${tooltip} style="cursor:pointer">${SCORE_LABELS[d.decision]}</span>`;
                };

                const scoreClass = (s) => {
                    if (s === null) return '';
                    if (s >= 7) return 'score-high';
                    if (s >= 5) return 'score-mid';
                    return 'score-low';
                };

                const getJudgmentSelect = (paperId, rank) => {
                    const current = adminJudgments[paperId] || '';
                    const defaultVal = cutoff > 0 && rank <= cutoff ? 'accepted' : (cutoff > 0 ? 'rejected' : '');
                    const val = current || defaultVal;
                    const cls = val === 'accepted' ? 'accepted' : (val === 'waitlisted' ? 'waitlisted' : (val === 'rejected' ? 'rejected' : ''));
                    return `
                        <select class="judgment-select ${cls}" onchange="setAdminJudgment('${paperId}', this.value)">
                            <option value="" ${!val ? 'selected' : ''}>--</option>
                            <option value="accepted" ${val === 'accepted' ? 'selected' : ''}>‚úì Accept</option>
                            <option value="waitlisted" ${val === 'waitlisted' ? 'selected' : ''}>‚è≥ Waitlist</option>
                            <option value="rejected" ${val === 'rejected' ? 'selected' : ''}>‚úó Reject</option>
                        </select>
                    `;
                };

                container.innerHTML = `
                <table>
                    <thead><tr><th>#</th><th></th><th>ID</th><th>Title</th><th>Authors</th><th>Institution</th><th>R1</th><th>R2</th><th>Score</th><th>Status</th><th>Nominations</th><th>Decision</th></tr></thead>
                    <tbody>
                        ${filteredScores.map((p) => {
                    const originalRank = scores.findIndex(s => s.id === p.id) + 1;
                    const isCutoff = cutoff > 0 && originalRank === cutoff;
                    const aboveCutoff = cutoff > 0 && originalRank <= cutoff;
                    const conflictClass = p.hasConflict ? 'conflict-row' : '';
                    const nomCount = Object.values(nominations).filter(n => n === p.id).length;
                    const authors = (p.authors || '').toString();
                    const affiliations = (p.affiliations || '').toString();
                    const authorsShort = authors ? (authors.length > 28 ? authors.substring(0, 28) + '‚Ä¶' : authors) : '-';
                    const affShort = affiliations ? (affiliations.length > 28 ? affiliations.substring(0, 28) + '‚Ä¶' : affiliations) : '-';
                    return `<tr class="${isCutoff ? 'cutoff-row' : ''} ${aboveCutoff ? 'above-cutoff' : ''} ${conflictClass}">
                                <td><span class="rank rank-normal">${originalRank}</span></td>
                                <td><button class="info-btn" onclick="showPaperDetails('${p.id}')">‚ÑπÔ∏è</button></td>
                                <td>${p.id}</td>
                                <td>${(p.title || 'TBD').substring(0, 30)}...</td>
                                <td class="cell-ellipsis" title="${authors.replace(/"/g, '&quot;')}">${authorsShort}</td>
                                <td class="cell-ellipsis" title="${affiliations.replace(/"/g, '&quot;')}">${affShort}</td>
                                <td>${badge(p.details[0])}</td>
                                <td>${badge(p.details[1])}</td>
                                <td><span class="score ${scoreClass(p.score)}">${p.score !== null ? p.score : '-'}</span></td>
                                <td>${p.hasConflict ? '<span class="status" style="background:#fef3c7;color:#92400e">‚ö† Conflict</span>' : (p.count >= 2 ? '<span class="status status-yes">Done</span>' : `<span class="status status-pending">${p.count}/2</span>`)}</td>
                                <td>${nomCount > 0 ? nomCount : '-'}</td>
                                <td>${getJudgmentSelect(p.id, originalRank)}</td>
                            </tr>`;
                }).join('')}
                    </tbody>
                </table>`;
            }

            function exportResults() {
                const scores = papers.map(p => ({ ...p, ...calcScore(p.id) }));
                // Sort by score, then by priority
                scores.sort((a, b) => {
                    if (a.score === null && b.score === null) return 0;
                    if (a.score === null) return 1;
                    if (b.score === null) return -1;
                    if (b.score !== a.score) return b.score - a.score;
                    return b.priority - a.priority;
                });

                const cutoff = parseInt(document.getElementById('cutoff-number')?.value) || 0;

                // Helper to build row data for a paper
                const buildRow = (p, rank) => {
                    const adminDecision = adminJudgments[p.id] || '';
                    const link = paperFiles[p.id]?.link || '';
                    const nomCount = Object.values(nominations).filter(n => n === p.id).length;
                    const r1Name = p.details[0]?.reviewerName || '';
                    const r1Dec = p.details[0] ? SCORE_LABELS[p.details[0].decision] : 'Pending';
                    const r2Name = p.details[1]?.reviewerName || '';
                    const r2Dec = p.details[1] ? SCORE_LABELS[p.details[1].decision] : 'Pending';
                    const status = p.count >= 2 ? 'Complete' : `${p.count}/2`;
                    const conflict = p.hasConflict ? 'YES' : '';
                    const pairLabel = getPairLabel(p.pairType);

                    return {
                        'Rank': rank,
                        'Paper ID': p.id,
                        'Original ID': p.originalId || '',
                        'Title': p.title || 'TBD',
                        'Authors': p.authors || '',
                        'Institution': p.affiliations || '',
                        'R1 Name': r1Name,
                        'R1 Decision': r1Dec,
                        'R2 Name': r2Name,
                        'R2 Decision': r2Dec,
                        'Pair Type': pairLabel,
                        'Total Score': p.score !== null ? p.score : '',
                        'Status': status,
                        'Nominations': nomCount,
                        'Admin Decision': adminDecision.toUpperCase(),
                        'Conflict': conflict,
                        'PDF Link': link
                    };
                };

                // Build all papers data with ranks
                const allPapersData = scores.map((p, i) => buildRow(p, i + 1));

                // Filter papers by decision
                const acceptedPapers = scores.filter(p =>
                    adminJudgments[p.id] === 'accepted' ||
                    (!adminJudgments[p.id] && cutoff > 0 && scores.indexOf(p) < cutoff)
                );
                const waitlistedPapers = scores.filter(p => adminJudgments[p.id] === 'waitlisted');
                const rejectedPapers = scores.filter(p => adminJudgments[p.id] === 'rejected');

                // Build sheet data for each category
                const acceptedData = acceptedPapers.map((p, i) => buildRow(p, i + 1));
                const waitlistedData = waitlistedPapers.map((p, i) => buildRow(p, i + 1));
                const rejectedData = rejectedPapers.map((p, i) => buildRow(p, i + 1));

                // Create workbook with SheetJS
                const wb = XLSX.utils.book_new();

                // Add All Papers sheet
                const wsAll = XLSX.utils.json_to_sheet(allPapersData);
                XLSX.utils.book_append_sheet(wb, wsAll, 'All Papers');

                // Add Accepted sheet
                if (acceptedData.length > 0) {
                    const wsAccepted = XLSX.utils.json_to_sheet(acceptedData);
                    XLSX.utils.book_append_sheet(wb, wsAccepted, 'Accepted');
                } else {
                    const wsAccepted = XLSX.utils.json_to_sheet([{ 'Note': 'No accepted papers' }]);
                    XLSX.utils.book_append_sheet(wb, wsAccepted, 'Accepted');
                }

                // Add Waitlisted sheet
                if (waitlistedData.length > 0) {
                    const wsWaitlisted = XLSX.utils.json_to_sheet(waitlistedData);
                    XLSX.utils.book_append_sheet(wb, wsWaitlisted, 'Waitlisted');
                } else {
                    const wsWaitlisted = XLSX.utils.json_to_sheet([{ 'Note': 'No waitlisted papers' }]);
                    XLSX.utils.book_append_sheet(wb, wsWaitlisted, 'Waitlisted');
                }

                // Add Rejected sheet
                if (rejectedData.length > 0) {
                    const wsRejected = XLSX.utils.json_to_sheet(rejectedData);
                    XLSX.utils.book_append_sheet(wb, wsRejected, 'Rejected');
                } else {
                    const wsRejected = XLSX.utils.json_to_sheet([{ 'Note': 'No rejected papers' }]);
                    XLSX.utils.book_append_sheet(wb, wsRejected, 'Rejected');
                }

                // Download the file
                XLSX.writeFile(wb, 'review_results.xlsx');
                showToast('Exported XLSX with 4 sheets: All Papers, Accepted, Waitlisted, Rejected');
            }

            function clearAllData() {
                if (!confirm('Delete ALL data?')) return;
                if (!confirm('Really? Cannot undo!')) return;
                db.ref('papers').remove();
                db.ref('reviewers').remove();
                db.ref('assignments').remove();
                db.ref('reviews').remove();
                db.ref('paperFiles').remove();
                db.ref('adminJudgments').remove();
                db.ref('nominations').remove();
                showToast('All data cleared');
            }

            // =====================
            // REVIEWER VIEW
            // =====================
            function showReviewerView(rid) {
                document.getElementById('admin-login').classList.add('hidden');
                document.getElementById('admin-view').classList.add('hidden');
                document.getElementById('reviewer-view').classList.remove('hidden');
                document.getElementById('mode-badge').textContent = 'Reviewer';

                document.getElementById('reviewer-name-display').textContent = 'Loading...';
                document.getElementById('reviewer-papers').innerHTML = '<div class="card"><div class="loading"><div class="spinner"></div></div><p style="text-align:center;color:var(--text-secondary)">Loading papers...</p></div>';
            }

            function renderReviewerPapers(rid) {
                const reviewer = reviewers.find(r => r.id === rid);

                if (!reviewer && dataLoaded.reviewers) {
                    document.getElementById('reviewer-view').innerHTML = `<div class="card"><div class="empty-state"><h2>‚ùå Invalid Link</h2><p>Reviewer "${rid}" not found.</p></div></div>`;
                    return;
                }
                if (!reviewer) return;

                document.getElementById('reviewer-name-display').textContent = reviewer.name;

                const assigned = assignments[rid] || [];
                document.getElementById('reviewer-paper-count').textContent = assigned.length;
                document.getElementById('total-assigned').textContent = assigned.length;

                const done = assigned.filter(pid => reviews[pid]?.[rid]).length;
                document.getElementById('completed-count').textContent = done;
                document.getElementById('review-progress').style.width = assigned.length > 0 ? `${(done / assigned.length) * 100}%` : '0%';

                // Update nomination display
                const nominatedPaperId = nominations[rid];
                const nominationDisplay = document.getElementById('nominated-paper-id');
                if (nominationDisplay) {
                    if (nominatedPaperId && assigned.includes(nominatedPaperId)) {
                        const nominatedPaper = papers.find(p => p.id === nominatedPaperId);
                        const titlePreview = nominatedPaper && nominatedPaper.title ? nominatedPaper.title.substring(0, 35) + (nominatedPaper.title.length > 35 ? '...' : '') : '';
                        nominationDisplay.innerHTML = `<strong>${nominatedPaperId}</strong> - ${titlePreview}`;
                        nominationDisplay.style.color = 'var(--success)';
                    } else {
                        nominationDisplay.textContent = 'None selected';
                        nominationDisplay.style.color = 'var(--text-secondary)';
                    }
                }

                if (done === assigned.length && assigned.length > 0) {
                    document.getElementById('all-done-card').classList.remove('hidden');
                } else {
                    document.getElementById('all-done-card').classList.add('hidden');
                }

                const container = document.getElementById('reviewer-papers');

                if (assigned.length === 0) {
                    container.innerHTML = '<div class="card"><div class="empty-state"><p>No papers assigned yet.</p></div></div>';
                    return;
                }

                container.innerHTML = assigned.map(pid => {
                    const paper = papers.find(p => p.id === pid);
                    if (!paper) return '';

                    const existing = reviews[pid]?.[rid];
                    const hasFile = paperFiles[pid]?.link;
                    const isNominated = nominations[rid] === pid;
                    const nominationUi = `
                        <div class="nomination-question">
                            <div class="nomination-question-text">Do you nominate this paper for Best Paper?</div>
                            <div class="nomination-actions">
                                <button class="btn-secondary btn-sm ${isNominated ? 'nom-yes-active' : ''}" onclick="setNomination('${rid}','${pid}', true)">Yes</button>
                                <button class="btn-secondary btn-sm" onclick="setNomination('${rid}','${pid}', false)">No</button>
                            </div>
                        </div>
                    `;

                    return `
                    <div class="paper-card ${existing ? 'reviewed' : ''} ${isNominated ? 'nominated-card' : ''}">
                        <div class="paper-header">
                             <div class="paper-content">
                                <div class="paper-id">${paper.id}</div>
                                <div class="paper-title">${paper.title || 'TBD'}</div>
                             </div>
                        </div>
                        
                        ${hasFile ? `<a href="${paperFiles[pid].link}" target="_blank" class="download-btn">üì• Download PDF</a>` : '<div class="alert alert-warning">PDF not available yet.</div>'}
                        
                        ${existing ? `
                            <div class="alert alert-success">
                                <strong>Your decision:</strong> ${SCORE_LABELS[existing.decision]} (Score: ${SCORE_MAP[existing.decision]})
                                <button class="btn-secondary btn-sm" style="margin-left:12px;" onclick="undoReview('${rid}','${pid}')">Change</button>
                            </div>
                        ` : `
                            <p style="color:var(--text-secondary);margin-bottom:12px">Select your recommendation:</p>
                            <div class="review-options">
                                <div class="review-option opt-no" onclick="submitReview('${rid}','${pid}','no')">
                                    <div class="option-label">No</div>
                                    <div class="option-score">Score: 1</div>
                                </div>
                                <div class="review-option opt-maybe-no" onclick="submitReview('${rid}','${pid}','maybe-no')">
                                    <div class="option-label">Maybe No</div>
                                    <div class="option-score">Score: 2</div>
                                </div>
                                <div class="review-option opt-maybe-yes" onclick="submitReview('${rid}','${pid}','maybe-yes')">
                                    <div class="option-label">Maybe Yes</div>
                                    <div class="option-score">Score: 3</div>
                                </div>
                                <div class="review-option opt-yes" onclick="submitReview('${rid}','${pid}','yes')">
                                    <div class="option-label">Yes</div>
                                    <div class="option-score">Score: 4</div>
                                </div>
                            </div>
                        `}
                        ${nominationUi}
                    </div>`;
                }).join('');
            }

            function undoReview(rid, pid) {
                if (!confirm('Change your decision?')) return;
                db.ref(`reviews/${pid}/${rid}`).remove();
            }

            function setNomination(rid, pid, isYes) {
                if (isYes) {
                    // Single nomination per reviewer.
                    // If they already nominated a different paper, prompt before replacing.
                    const existing = nominations[rid];
                    if (existing && existing !== pid) {
                        const ok = confirm(`You already nominated ${existing} for Best Paper.\n\nReplace it with ${pid}?`);
                        if (!ok) return;
                    }
                    db.ref(`nominations/${rid}`).set(pid);
                    // Immediately update local state and display
                    nominations[rid] = pid;
                    updateNominationDisplay(rid);
                    showToast("Nomination saved");
                    return;
                }
                // "No" clears nomination only if this paper is currently nominated.
                if (nominations[rid] === pid) {
                    db.ref(`nominations/${rid}`).remove();
                    // Immediately update local state and display
                    delete nominations[rid];
                    updateNominationDisplay(rid);
                    showToast("Nomination cleared");
                }
            }

            // Helper function to update nomination display
            function updateNominationDisplay(rid) {
                const nominationDisplay = document.getElementById('nominated-paper-id');
                if (!nominationDisplay) return;

                const nominatedPaperId = nominations[rid];
                const assigned = assignments[rid] || [];

                if (nominatedPaperId && assigned.includes(nominatedPaperId)) {
                    // Find paper title
                    const paper = papers.find(p => p.id === nominatedPaperId);
                    const titlePreview = paper && paper.title ? paper.title.substring(0, 35) + (paper.title.length > 35 ? '...' : '') : '';
                    nominationDisplay.innerHTML = `<strong>${nominatedPaperId}</strong> - ${titlePreview}`;
                    nominationDisplay.style.color = 'var(--success)';
                } else {
                    nominationDisplay.textContent = 'None selected';
                    nominationDisplay.style.color = 'var(--text-secondary)';
                }

                // Also update the nomination buttons styling
                renderReviewerPapers(rid);
            }

            function submitReview(rid, pid, decision) {
                db.ref(`reviews/${pid}/${rid}`).set({
                    decision,
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                });
                showToast('Submitted: ' + SCORE_LABELS[decision]);
            }
        </script>

        <!-- Footer -->
        <footer class="cu-footer">
            <div class="footer-content">
                <!-- Logo removed -->
                <div class="footer-text">
                    <p><strong>Strategy Science Conference 2026</strong></p>
                    <p>Leeds School of Business ¬∑ University of Colorado Boulder</p>
                    <p class="footer-address">995 Regent Drive, Boulder, CO 80309</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>¬© 2026 Strategy Science Conference. All rights reserved.</p>
            </div>
        </footer>

        <style>
            .cu-footer {
                background: linear-gradient(135deg, #000000 0%, #1a1a1a 100%);
                color: #fff;
                padding: 40px 20px 20px;
                margin-top: 60px;
            }

            .footer-content {
                max-width: 1100px;
                margin: 0 auto;
                display: flex;
                align-items: center;
                gap: 20px;
                padding-bottom: 20px;
                border-bottom: 1px solid rgba(207, 184, 124, 0.3);
            }

            .footer-logo svg {
                display: block;
            }

            .footer-text p {
                margin: 4px 0;
                font-size: 0.9rem;
            }

            .footer-text strong {
                color: #CFB87C;
                font-size: 1.1rem;
            }

            .footer-address {
                color: #888;
                font-size: 0.8rem !important;
            }

            .footer-bottom {
                max-width: 1100px;
                margin: 0 auto;
                padding-top: 20px;
                text-align: center;
            }

            .footer-bottom p {
                color: #666;
                font-size: 0.8rem;
            }
        </style>
    </body>

</html>